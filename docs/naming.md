<!--
GENERATED FILE - DO NOT EDIT
This file was generated by [MarkdownSnippets](https://github.com/SimonCropp/MarkdownSnippets).
Source File: /docs/mdsource/naming.source.md
To change this file edit the source file and then run MarkdownSnippets.
-->

# File Naming

Naming determines the file name for the `.received.` resulting `.verified.` files.

The format is

```
{Directory}/{TestClassName}.{TestMethodName}_{Parameters}_{UniqueFor1}_{UniqueFor2}_{UniqueForX}.verified.{extension}
```


## Directory

The directory that contains the test. A custom directory can be used via `UseDirectory`:

<!-- snippet: UseDirectory -->
<a id='snippet-usedirectory'></a>
```cs
VerifySettings settings = new();
settings.UseDirectory("CustomDirectory");
await Verifier.Verify("value", settings);
```
<sup><a href='/src/Verify.Tests/Naming/NamerTests.cs#L86-L92' title='Snippet source file'>snippet source</a> | <a href='#snippet-usedirectory' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->

<!-- snippet: UseDirectoryFluent -->
<a id='snippet-usedirectoryfluent'></a>
```cs
await Verifier.Verify("value")
    .UseDirectory("CustomDirectory");
```
<sup><a href='/src/Verify.Tests/Naming/NamerTests.cs#L98-L103' title='Snippet source file'>snippet source</a> | <a href='#snippet-usedirectoryfluent' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->

Will result in `CustomDirectory/TypeName.MethodName.verified.txt`.

The path provided can be absolute or relative to the directory that contains the test.


## TestClassName

The class name that contains the test. A custom test name can be used via `UseTypeName`:

<!-- snippet: UseTypeName -->
<a id='snippet-usetypename'></a>
```cs
VerifySettings settings = new();
settings.UseTypeName("CustomTypeName");
await Verifier.Verify("value", settings);
```
<sup><a href='/src/Verify.Tests/Naming/NamerTests.cs#L109-L115' title='Snippet source file'>snippet source</a> | <a href='#snippet-usetypename' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->

<!-- snippet: UseTypeNameFluent -->
<a id='snippet-usetypenamefluent'></a>
```cs
await Verifier.Verify("value")
    .UseTypeName("CustomTypeName");
```
<sup><a href='/src/Verify.Tests/Naming/NamerTests.cs#L121-L126' title='Snippet source file'>snippet source</a> | <a href='#snippet-usetypenamefluent' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->

Will result in `CustomTypeName.MethodName.verified.txt`.


## TestMethodName

The test method name. A custom test name can be used via `UseMethodName`:

<!-- snippet: UseMethodName -->
<a id='snippet-usemethodname'></a>
```cs
VerifySettings settings = new();
settings.UseMethodName("CustomMethodName");
await Verifier.Verify("value", settings);
```
<sup><a href='/src/Verify.Tests/Naming/NamerTests.cs#L132-L138' title='Snippet source file'>snippet source</a> | <a href='#snippet-usemethodname' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->

Will result in `TestClass.CustomMethodName.verified.txt`.

<!-- snippet: UseMethodNameFluent -->
<a id='snippet-usemethodnamefluent'></a>
```cs
await Verifier.Verify("value")
    .UseMethodName("CustomMethodNameFluent");
```
<sup><a href='/src/Verify.Tests/Naming/NamerTests.cs#L144-L149' title='Snippet source file'>snippet source</a> | <a href='#snippet-usemethodnamefluent' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->

Will result in `TestClass.CustomMethodNameFluent.verified.txt`.


## UseFileName

To fully control the `{TestClassName}.{TestMethodName}_{Parameters}` parts of the file use `UseFileName`:

<!-- snippet: UseFileName -->
<a id='snippet-usefilename'></a>
```cs
VerifySettings settings = new();
settings.UseFileName("CustomFileName");
await Verifier.Verify("value", settings);
```
<sup><a href='/src/Verify.Tests/Naming/NamerTests.cs#L54-L60' title='Snippet source file'>snippet source</a> | <a href='#snippet-usefilename' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->

Will result in `CustomFileName.verified.txt`.

<!-- snippet: UseFileNameFluent -->
<a id='snippet-usefilenamefluent'></a>
```cs
await Verifier.Verify("value")
    .UseFileName("CustomFileNameFluent");
```
<sup><a href='/src/Verify.Tests/Naming/NamerTests.cs#L75-L80' title='Snippet source file'>snippet source</a> | <a href='#snippet-usefilenamefluent' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->

Will result in `UseFileNameFluent.verified.txt`.

Compatibility:

 * Not compatible with `UseTypeName`, `UseMethodName`, or `UseParameters`. An exception will be thrown if they are combined.
 * Can be used in combination with `UseDirectory`.
 * Can be used in combination with `UniqueFor*`.


## Parameters

See [Parameterised Tests](parameterised.md).


## UniqueFor

`UniqueFor*` allows for one or more delimiters to be added to the file name.


### XUnit

<!-- snippet: UniqueForSampleXunit -->
<a id='snippet-uniqueforsamplexunit'></a>
```cs
[UsesVerify]
public class UniqueForSample
{
    [Fact]
    public Task Runtime()
    {
        VerifySettings settings = new();
        settings.UniqueForRuntime();
        return Verifier.Verify("value", settings);
    }

    [Fact]
    public Task RuntimeFluent()
    {
        return Verifier.Verify("value")
            .UniqueForRuntime();
    }

    [Fact]
    public Task RuntimeAndVersion()
    {
        VerifySettings settings = new();
        settings.UniqueForRuntimeAndVersion();
        return Verifier.Verify("value", settings);
    }

    [Fact]
    public Task AssemblyConfiguration()
    {
        VerifySettings settings = new();
        settings.UniqueForAssemblyConfiguration();
        return Verifier.Verify("value", settings);
    }

    [Fact]
    public Task AssemblyConfigurationFluent()
    {
        return Verifier.Verify("value")
            .UniqueForAssemblyConfiguration();
    }

    [Fact]
    public Task Architecture()
    {
        VerifySettings settings = new();
        settings.UniqueForArchitecture();
        return Verifier.Verify("value", settings);
    }

    [Fact]
    public Task ArchitectureFluent()
    {
        return Verifier.Verify("value")
            .UniqueForArchitecture();
    }

    [Fact]
    public Task OSPlatform()
    {
        VerifySettings settings = new();
        settings.UniqueForOSPlatform();
        return Verifier.Verify("value", settings);
    }

    [Fact]
    public Task OSPlatformFluent()
    {
        return Verifier.Verify("value")
            .UniqueForOSPlatform();
    }
}
```
<sup><a href='/src/Verify.Xunit.Tests/Snippets/UniqueForSample.cs#L6-L80' title='Snippet source file'>snippet source</a> | <a href='#snippet-uniqueforsamplexunit' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->


### NUnit

<!-- snippet: UniqueForSampleNUnit -->
<a id='snippet-uniqueforsamplenunit'></a>
```cs
[TestFixture]
public class UniqueForSample
{
    [Test]
    public Task Runtime()
    {
        VerifySettings settings = new();
        settings.UniqueForRuntime();
        return Verifier.Verify("value", settings);
    }

    [Test]
    public Task RuntimeFluent()
    {
        return Verifier.Verify("value")
            .UniqueForRuntime();
    }

    [Test]
    public Task AssemblyConfiguration()
    {
        VerifySettings settings = new();
        settings.UniqueForAssemblyConfiguration();
        return Verifier.Verify("value", settings);
    }

    [Test]
    public Task AssemblyConfigurationFluent()
    {
        return Verifier.Verify("value")
            .UniqueForAssemblyConfiguration();
    }

    [Test]
    public Task RuntimeAndVersion()
    {
        VerifySettings settings = new();
        settings.UniqueForRuntimeAndVersion();
        return Verifier.Verify("value", settings);
    }

    [Test]
    public Task RuntimeAndVersionFluent()
    {
        return Verifier.Verify("value")
            .UniqueForRuntimeAndVersion();
    }

    [Test]
    public Task Architecture()
    {
        VerifySettings settings = new();
        settings.UniqueForArchitecture();
        return Verifier.Verify("value", settings);
    }

    [Test]
    public Task ArchitectureFluent()
    {
        return Verifier.Verify("value")
            .UniqueForArchitecture();
    }

    [Test]
    public Task OSPlatform()
    {
        VerifySettings settings = new();
        settings.UniqueForOSPlatform();
        return Verifier.Verify("value", settings);
    }

    [Test]
    public Task OSPlatformFluent()
    {
        return Verifier.Verify("value")
            .UniqueForOSPlatform();
    }
}
```
<sup><a href='/src/Verify.NUnit.Tests/Snippets/UniqueForSample.cs#L6-L87' title='Snippet source file'>snippet source</a> | <a href='#snippet-uniqueforsamplenunit' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->


### MSTest

<!-- snippet: UniqueForSampleMSTest -->
<a id='snippet-uniqueforsamplemstest'></a>
```cs
[TestClass]
public class UniqueForSample :
    VerifyBase
{
    [TestMethod]
    public Task Runtime()
    {
        VerifySettings settings = new();
        settings.UniqueForRuntime();
        return Verify("value", settings);
    }

    [TestMethod]
    public Task RuntimeFluent()
    {
        return Verify("value")
            .UniqueForRuntime();
    }

    [TestMethod]
    public Task RuntimeAndVersion()
    {
        VerifySettings settings = new();
        settings.UniqueForRuntimeAndVersion();
        return Verify("value", settings);
    }

    [TestMethod]
    public Task RuntimeAndVersionFluent()
    {
        return Verify("value")
            .UniqueForRuntimeAndVersion();
    }

    [TestMethod]
    public Task AssemblyConfiguration()
    {
        VerifySettings settings = new();
        settings.UniqueForAssemblyConfiguration();
        return Verify("value", settings);
    }

    [TestMethod]
    public Task AssemblyConfigurationFluent()
    {
        return Verify("value")
            .UniqueForAssemblyConfiguration();
    }

    [TestMethod]
    public Task Architecture()
    {
        VerifySettings settings = new();
        settings.UniqueForArchitecture();
        return Verify("value", settings);
    }

    [TestMethod]
    public Task ArchitectureFluent()
    {
        return Verify("value")
            .UniqueForArchitecture();
    }

    [TestMethod]
    public Task OSPlatform()
    {
        VerifySettings settings = new();
        settings.UniqueForOSPlatform();
        return Verify("value", settings);
    }

    [TestMethod]
    public Task OSPlatformFluent()
    {
        return Verify("value")
            .UniqueForOSPlatform();
    }
}
```
<sup><a href='/src/Verify.MSTest.Tests/Snippets/UniqueForSample.cs#L6-L88' title='Snippet source file'>snippet source</a> | <a href='#snippet-uniqueforsamplemstest' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->


### Result

For a project executed on both x64 and x86 that targets

```
<TargetFrameworks>netcoreapp3.0;net48</TargetFrameworks>
```

Will result in the following files being produced:

```
UniqueForSample.Runtime.Core.verified.txt
UniqueForSample.Runtime.Net.verified.txt
UniqueForSample.RuntimeAndVersion.Core3_0.verified.txt
UniqueForSample.RuntimeAndVersion.Net4_8.verified.txt
UniqueForSample.Architecture.X86.verified.txt
UniqueForSample.Architecture.X64.verified.txt
```


## Extension

The default file extension is `.txt`. So the resulting verified file will be `TestClass.TestMethod.verified.txt`.

It can be overridden at two levels:

 * Method: Change the extension for the current test method.
 * Class: Change the extension all verifications in all test methods for a test class.

Usage:

<!-- snippet: XunitExtensionSample -->
<a id='snippet-xunitextensionsample'></a>
```cs
[UsesVerify]
public class ExtensionSample
{
    VerifySettings classLevelSettings;

    public ExtensionSample()
    {
        classLevelSettings = new();
        classLevelSettings.UseExtension("json");
    }

    [Fact]
    public Task AtMethod()
    {
        VerifySettings settings = new(classLevelSettings);
        settings.UseExtension("xml");
        return Verifier.Verify(
            target: @"
<note>
  <to>Joe</to>
  <from>Kim</from>
  <heading>Reminder</heading>
</note>",
            settings: settings);
    }

    [Fact]
    public Task AtMethodFluent()
    {
        return Verifier.Verify(
                target: @"
<note>
  <to>Joe</to>
  <from>Kim</from>
  <heading>Reminder</heading>
</note>",
                settings: classLevelSettings)
            .UseExtension("xml");
    }

    [Fact]
    public Task SharedClassLevelSettings()
    {
        return Verifier.Verify(
            target: @"
{
  fruit: 'Apple',
  size: 'Large',
  color: 'Red'
}",
            settings: classLevelSettings);
    }
}
```
<sup><a href='/src/Verify.Xunit.Tests/Snippets/ExtensionSample.cs#L6-L62' title='Snippet source file'>snippet source</a> | <a href='#snippet-xunitextensionsample' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->

Result in two files:

<!-- snippet: Verify.Xunit.Tests/Snippets/ExtensionSample.SharedClassLevelSettings.verified.json -->
<a id='snippet-Verify.Xunit.Tests/Snippets/ExtensionSample.SharedClassLevelSettings.verified.json'></a>
```json
{
  fruit: 'Apple',
  size: 'Large',
  color: 'Red'
}
```
<sup><a href='/src/Verify.Xunit.Tests/Snippets/ExtensionSample.SharedClassLevelSettings.verified.json#L1-L6' title='Snippet source file'>snippet source</a> | <a href='#snippet-Verify.Xunit.Tests/Snippets/ExtensionSample.SharedClassLevelSettings.verified.json' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->

<!-- snippet: Verify.Xunit.Tests/Snippets/ExtensionSample.AtMethod.verified.xml -->
<a id='snippet-Verify.Xunit.Tests/Snippets/ExtensionSample.AtMethod.verified.xml'></a>
```xml
<note>
  <to>Joe</to>
  <from>Kim</from>
  <heading>Reminder</heading>
</note>
```
<sup><a href='/src/Verify.Xunit.Tests/Snippets/ExtensionSample.AtMethod.verified.xml#L1-L6' title='Snippet source file'>snippet source</a> | <a href='#snippet-Verify.Xunit.Tests/Snippets/ExtensionSample.AtMethod.verified.xml' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->


## NamerRuntimeAndVersion

To access the current Namer `Runtime` or `RuntimeAndVersion` strings use:

<!-- snippet: AccessNamerRuntimeAndVersion -->
<a id='snippet-accessnamerruntimeandversion'></a>
```cs
Debug.WriteLine(Namer.Runtime);
Debug.WriteLine(Namer.RuntimeAndVersion);
```
<sup><a href='/src/Verify.Tests/Naming/NamerTests.cs#L155-L160' title='Snippet source file'>snippet source</a> | <a href='#snippet-accessnamerruntimeandversion' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->


## DerivePathInfo

`DerivePathInfo` allows the storage directory of `.verified.` files to be customized based on the current context. The contextual parameters are parameters passed are as follows:

 * `sourceFile`: The full path to the file that the test existed in at compile time.
 * `projectDirectory`: The directory that the project existed in at compile time.
 * `type`: The class the test method exists in.
 * `method`: The test method.


For example to place all `.verified.` files in a `{ProjectDirectory}\Snapshots` the following could be used:

<!-- snippet: DerivePathInfo -->
<a id='snippet-derivepathinfo'></a>
```cs
VerifierSettings.DerivePathInfo(
    (sourceFile, projectDirectory, type, method) =>
    {
        return new(
            directory: Path.Combine(projectDirectory, "Snapshots"),
            typeName: type.Name,
            methodName: method.Name);
    });
```
<sup><a href='/src/Verify.Tests/Snippets/Snippets.cs#L66-L77' title='Snippet source file'>snippet source</a> | <a href='#snippet-derivepathinfo' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->

Return null to any of the values to use the standard behavior. The returned path can be relative to the directory sourceFile exists in.

`DerivePathInfo` can also be useful when deriving the storage directory on a [build server](build-server.md#custom-directory-and-file-name)

A `DerivePathInfo` convention can be shipped as a NuGet, for example [Spectre.Verify.Extensions](https://github.com/spectresystems/spectre.verify.extensions) which adds an attribute driven file naming convention to Verify.


### Default DerivePathInfo

<!-- snippet: defaultDerivePathInfo -->
<a id='snippet-defaultderivepathinfo'></a>
```cs
static DerivePathInfo derivePathInfo = (sourceFile, projectDirectory, type, method) =>
{
    static string GetTypeName(Type type)
    {
        if (type.IsNested)
        {
            return $"{type.ReflectedType!.Name}.{type.Name}";
        }

        return type.Name;
    }

    var typeName = GetTypeName(type);

    return new(Path.GetDirectoryName(sourceFile)!, typeName, method.Name);
};
```
<sup><a href='/src/Verify/DerivePaths/VerifierSettings.cs#L10-L27' title='Snippet source file'>snippet source</a> | <a href='#snippet-defaultderivepathinfo' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->
