<!--
GENERATED FILE - DO NOT EDIT
This file was generated by [MarkdownSnippets](https://github.com/SimonCropp/MarkdownSnippets).
Source File: /docs/mdsource/naming.source.md
To change this file edit the source file and then run MarkdownSnippets.
-->

# File Naming

Naming determines the file name for the `.received.` resulting `.verified.` files.

The format is

```
{Directory}/{TestClassName}.{TestMethodName}_{Parameters}_{UniqueFor1}_{UniqueFor2}_{UniqueForX}.verified.{extension}
```


## Directory

The directory that contains the test. A custom directory can be used via `UseDirectory`:

<!-- snippet: UseDirectory -->
<a id='snippet-usedirectory'></a>
```cs
var settings = new VerifySettings();
settings.UseDirectory("CustomDirectory");
await Verify("valueUseDirectory", settings);
```
<sup><a href='/src/Verify.Tests/Naming/NamerTests.cs#L200-L206' title='Snippet source file'>snippet source</a> | <a href='#snippet-usedirectory' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->

<!-- snippet: UseDirectoryFluent -->
<a id='snippet-usedirectoryfluent'></a>
```cs
await Verify("valueUseDirectoryFluent")
    .UseDirectory("CustomDirectory");
```
<sup><a href='/src/Verify.Tests/Naming/NamerTests.cs#L212-L217' title='Snippet source file'>snippet source</a> | <a href='#snippet-usedirectoryfluent' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->

Will result in `CustomDirectory/TypeName.MethodName.verified.txt`.

The path provided can be absolute or relative to the directory that contains the test.


## TestClassName

The class name that contains the test. A custom test name can be used via `UseTypeName`:

<!-- snippet: UseTypeName -->
<a id='snippet-usetypename'></a>
```cs
var settings = new VerifySettings();
settings.UseTypeName("CustomTypeName");
await Verify("valueUseTypeName", settings);
```
<sup><a href='/src/Verify.Tests/Naming/NamerTests.cs#L311-L317' title='Snippet source file'>snippet source</a> | <a href='#snippet-usetypename' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->

<!-- snippet: UseTypeNameFluent -->
<a id='snippet-usetypenamefluent'></a>
```cs
await Verify("valueUseTypeNameFluent")
    .UseTypeName("CustomTypeName");
```
<sup><a href='/src/Verify.Tests/Naming/NamerTests.cs#L323-L328' title='Snippet source file'>snippet source</a> | <a href='#snippet-usetypenamefluent' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->

Will result in `CustomTypeName.MethodName.verified.txt`.


## TestMethodName

The test method name. A custom test name can be used via `UseMethodName`:

<!-- snippet: UseMethodName -->
<a id='snippet-usemethodname'></a>
```cs
var settings = new VerifySettings();
settings.UseMethodName("CustomMethodName");
await Verify("valueUseMethodName", settings);
```
<sup><a href='/src/Verify.Tests/Naming/NamerTests.cs#L334-L340' title='Snippet source file'>snippet source</a> | <a href='#snippet-usemethodname' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->

Will result in `TestClass.CustomMethodName.verified.txt`.

<!-- snippet: UseMethodNameFluent -->
<a id='snippet-usemethodnamefluent'></a>
```cs
await Verify("valueUseMethodNameFluent")
    .UseMethodName("CustomMethodNameFluent");
```
<sup><a href='/src/Verify.Tests/Naming/NamerTests.cs#L346-L351' title='Snippet source file'>snippet source</a> | <a href='#snippet-usemethodnamefluent' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->

Will result in `TestClass.CustomMethodNameFluent.verified.txt`.


### Multiple calls to Verify

`UseMethodName` can also be used to allow multiple calls to Verify in the same method:

<!-- snippet: MultipleCalls -->
<a id='snippet-multiplecalls'></a>
```cs
[Fact]
public Task MultipleCalls() =>
    Task.WhenAll(
        Verify("Value1MultipleCalls")
            .UseMethodName("MultipleCalls_1"),
        Verify("Value1MultipleCalls")
            .UseMethodName("MultipleCalls_2"));
```
<sup><a href='/src/Verify.Tests/Naming/NamerTests.cs#L52-L62' title='Snippet source file'>snippet source</a> | <a href='#snippet-multiplecalls' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->


## UseFileName

To fully control the `{TestClassName}.{TestMethodName}_{Parameters}` parts of the file use `UseFileName`:

<!-- snippet: UseFileName -->
<a id='snippet-usefilename'></a>
```cs
var settings = new VerifySettings();
settings.UseFileName("CustomFileName");
await Verify("valueUseFileName", settings);
```
<sup><a href='/src/Verify.Tests/Naming/NamerTests.cs#L168-L174' title='Snippet source file'>snippet source</a> | <a href='#snippet-usefilename' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->

Will result in `CustomFileName.verified.txt`.

<!-- snippet: UseFileNameFluent -->
<a id='snippet-usefilenamefluent'></a>
```cs
await Verify("valueUseFileNameFluent")
    .UseFileName("CustomFileNameFluent");
```
<sup><a href='/src/Verify.Tests/Naming/NamerTests.cs#L189-L194' title='Snippet source file'>snippet source</a> | <a href='#snippet-usefilenamefluent' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->

Will result in `UseFileNameFluent.verified.txt`.

Compatibility:

 * Not compatible with `UseTypeName`, `UseMethodName`, or `UseParameters`. An exception will be thrown if they are combined.
 * Can be used in combination with `UseDirectory`.
 * Can be used in combination with `UniqueFor*`.


## Parameters

See [Parameterised Tests](parameterised.md).


## UniqueFor

`UniqueFor*` allows for one or more delimiters to be added to the file name.


### NUnit

<!-- snippet: UniqueForSampleNUnit -->
<a id='snippet-uniqueforsamplenunit'></a>
```cs
[TestFixture]
public class UniqueForSample
{
    [Test]
    public Task Runtime()
    {
        var settings = new VerifySettings();
        settings.UniqueForRuntime();
        return Verify("value", settings);
    }

    [Test]
    public Task RuntimeFluent() =>
        Verify("value")
            .UniqueForRuntime();

    [Test]
    public Task AssemblyConfiguration()
    {
        var settings = new VerifySettings();
        settings.UniqueForAssemblyConfiguration();
        return Verify("value", settings);
    }

    [Test]
    public Task AssemblyConfigurationFluent() =>
        Verify("value")
            .UniqueForAssemblyConfiguration();

    [Test]
    public Task RuntimeAndVersion()
    {
        var settings = new VerifySettings();
        settings.UniqueForRuntimeAndVersion();
        return Verify("value", settings);
    }

    [Test]
    public Task RuntimeAndVersionFluent() =>
        Verify("value")
            .UniqueForRuntimeAndVersion();

    [Test]
    public Task Architecture()
    {
        var settings = new VerifySettings();
        settings.UniqueForArchitecture();
        return Verify("value", settings);
    }

    [Test]
    public Task ArchitectureFluent() =>
        Verify("value")
            .UniqueForArchitecture();

    [Test]
    public Task OSPlatform()
    {
        var settings = new VerifySettings();
        settings.UniqueForOSPlatform();
        return Verify("value", settings);
    }

    [Test]
    public Task OSPlatformFluent() =>
        Verify("value")
            .UniqueForOSPlatform();
}
```
<sup><a href='/src/Verify.NUnit.Tests/Snippets/UniqueForSample.cs#L1-L72' title='Snippet source file'>snippet source</a> | <a href='#snippet-uniqueforsamplenunit' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->


### XUnit

<!-- snippet: UniqueForSampleXunit -->
<a id='snippet-uniqueforsamplexunit'></a>
```cs
[UsesVerify]
public class UniqueForSample
{
    [Fact]
    public Task Runtime()
    {
        var settings = new VerifySettings();
        settings.UniqueForRuntime();
        return Verify("value", settings);
    }

    [Fact]
    public Task RuntimeFluent() =>
        Verify("value")
            .UniqueForRuntime();

    [Fact]
    public Task RuntimeAndVersion()
    {
        var settings = new VerifySettings();
        settings.UniqueForRuntimeAndVersion();
        return Verify("value", settings);
    }

    [Fact]
    public Task AssemblyConfiguration()
    {
        var settings = new VerifySettings();
        settings.UniqueForAssemblyConfiguration();
        return Verify("value", settings);
    }

    [Fact]
    public Task AssemblyConfigurationFluent() =>
        Verify("value")
            .UniqueForAssemblyConfiguration();

    [Fact]
    public Task Architecture()
    {
        var settings = new VerifySettings();
        settings.UniqueForArchitecture();
        return Verify("value", settings);
    }

    [Fact]
    public Task ArchitectureFluent() =>
        Verify("value")
            .UniqueForArchitecture();

    [Fact]
    public Task OSPlatform()
    {
        var settings = new VerifySettings();
        settings.UniqueForOSPlatform();
        return Verify("value", settings);
    }

    [Fact]
    public Task OSPlatformFluent() =>
        Verify("value")
            .UniqueForOSPlatform();
}
```
<sup><a href='/src/Verify.Xunit.Tests/Snippets/UniqueForSample.cs#L1-L67' title='Snippet source file'>snippet source</a> | <a href='#snippet-uniqueforsamplexunit' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->


### Fixie

<!-- snippet: UniqueForSampleFixie -->
<a id='snippet-uniqueforsamplefixie'></a>
```cs
public class UniqueForSample
{
    public Task Runtime()
    {
        var settings = new VerifySettings();
        settings.UniqueForRuntime();
        return Verify("value", settings);
    }

    public Task RuntimeFluent() =>
        Verify("value")
            .UniqueForRuntime();

    public Task AssemblyConfiguration()
    {
        var settings = new VerifySettings();
        settings.UniqueForAssemblyConfiguration();
        return Verify("value", settings);
    }

    public Task AssemblyConfigurationFluent() =>
        Verify("value")
            .UniqueForAssemblyConfiguration();

    public Task RuntimeAndVersion()
    {
        var settings = new VerifySettings();
        settings.UniqueForRuntimeAndVersion();
        return Verify("value", settings);
    }

    public Task RuntimeAndVersionFluent() =>
        Verify("value")
            .UniqueForRuntimeAndVersion();

    public Task Architecture()
    {
        var settings = new VerifySettings();
        settings.UniqueForArchitecture();
        return Verify("value", settings);
    }

    public Task ArchitectureFluent() =>
        Verify("value")
            .UniqueForArchitecture();

    public Task OSPlatform()
    {
        var settings = new VerifySettings();
        settings.UniqueForOSPlatform();
        return Verify("value", settings);
    }

    public Task OSPlatformFluent() =>
        Verify("value")
            .UniqueForOSPlatform();
}
```
<sup><a href='/src/Verify.Fixie.Tests/Snippets/UniqueForSample.cs#L1-L61' title='Snippet source file'>snippet source</a> | <a href='#snippet-uniqueforsamplefixie' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->


### MSTest

<!-- snippet: UniqueForSampleMSTest -->
<a id='snippet-uniqueforsamplemstest'></a>
```cs
[TestClass]
public class UniqueForSample :
    VerifyBase
{
    [TestMethod]
    public Task Runtime()
    {
        var settings = new VerifySettings();
        settings.UniqueForRuntime();
        return Verify("value", settings);
    }

    [TestMethod]
    public Task RuntimeFluent() =>
        Verify("value")
            .UniqueForRuntime();

    [TestMethod]
    public Task RuntimeAndVersion()
    {
        var settings = new VerifySettings();
        settings.UniqueForRuntimeAndVersion();
        return Verify("value", settings);
    }

    [TestMethod]
    public Task RuntimeAndVersionFluent() =>
        Verify("value")
            .UniqueForRuntimeAndVersion();

    [TestMethod]
    public Task AssemblyConfiguration()
    {
        var settings = new VerifySettings();
        settings.UniqueForAssemblyConfiguration();
        return Verify("value", settings);
    }

    [TestMethod]
    public Task AssemblyConfigurationFluent() =>
        Verify("value")
            .UniqueForAssemblyConfiguration();

    [TestMethod]
    public Task Architecture()
    {
        var settings = new VerifySettings();
        settings.UniqueForArchitecture();
        return Verify("value", settings);
    }

    [TestMethod]
    public Task ArchitectureFluent() =>
        Verify("value")
            .UniqueForArchitecture();

    [TestMethod]
    public Task OSPlatform()
    {
        var settings = new VerifySettings();
        settings.UniqueForOSPlatform();
        return Verify("value", settings);
    }

    [TestMethod]
    public Task OSPlatformFluent() =>
        Verify("value")
            .UniqueForOSPlatform();
}
```
<sup><a href='/src/Verify.MSTest.Tests/Snippets/UniqueForSample.cs#L3-L75' title='Snippet source file'>snippet source</a> | <a href='#snippet-uniqueforsamplemstest' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->


### Expecto

<!-- snippet: UniqueForSampleExpecto -->
<a id='snippet-uniqueforsampleexpecto'></a>
```fs
[<Tests>]
let uniqueTests =
    testTask "unique" {
        let settings = VerifySettings()
        settings.UniqueForRuntime()
        do! Verifier.Verify("unique", "value", settings)
    }
```
<sup><a href='/src/Verify.Expecto.FSharpTests/Tests.fs#L16-L24' title='Snippet source file'>snippet source</a> | <a href='#snippet-uniqueforsampleexpecto' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->


### Result

For a project executed on both x64 and x86 that targets

```
<TargetFrameworks>netcoreapp3.0;net48</TargetFrameworks>
```

Will result in the following files being produced:

```
UniqueForSample.Runtime.Core.verified.txt
UniqueForSample.Runtime.Net.verified.txt
UniqueForSample.RuntimeAndVersion.Core3_0.verified.txt
UniqueForSample.RuntimeAndVersion.Net4_8.verified.txt
UniqueForSample.Architecture.X86.verified.txt
UniqueForSample.Architecture.X64.verified.txt
```


## Extension

The default file extension is `.txt`. So the resulting verified file will be `TestClass.TestMethod.verified.txt`.

It can be overridden at two levels:

 * Method: Change the extension for the current test method.
 * Class: Change the extension all verifications in all test methods for a test class.

Usage:

<!-- snippet: XunitExtensionSample -->
<a id='snippet-xunitextensionsample'></a>
```cs
[UsesVerify]
public class ExtensionSample
{
    [Fact]
    public Task AtMethod() =>
        Verify(
            target: """
                    <note>
                      <to>Joe</to>
                      <from>Kim</from>
                      <heading>Reminder</heading>
                    </note>
                    """,
            extension: "xml");

    [Fact]
    public Task AtMethodFluent() =>
        Verify(
            target: """
                    <note>
                      <to>Joe</to>
                      <from>Kim</from>
                      <heading>Reminder</heading>
                    </note>
                    """,
            extension: "xml");
}
```
<sup><a href='/src/Verify.Xunit.Tests/Snippets/ExtensionSample.cs#L1-L31' title='Snippet source file'>snippet source</a> | <a href='#snippet-xunitextensionsample' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->

Result in:

<!-- snippet: Verify.Xunit.Tests/Snippets/ExtensionSample.AtMethod.verified.xml -->
<a id='snippet-Verify.Xunit.Tests/Snippets/ExtensionSample.AtMethod.verified.xml'></a>
```xml
<note>
  <to>Joe</to>
  <from>Kim</from>
  <heading>Reminder</heading>
</note>
```
<sup><a href='/src/Verify.Xunit.Tests/Snippets/ExtensionSample.AtMethod.verified.xml#L1-L5' title='Snippet source file'>snippet source</a> | <a href='#snippet-Verify.Xunit.Tests/Snippets/ExtensionSample.AtMethod.verified.xml' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->


## NamerRuntimeAndVersion

To access the current Namer `Runtime` or `RuntimeAndVersion` strings use:

<!-- snippet: AccessNamerRuntimeAndVersion -->
<a id='snippet-accessnamerruntimeandversion'></a>
```cs
Debug.WriteLine(Namer.Runtime);
Debug.WriteLine(Namer.RuntimeAndVersion);
```
<sup><a href='/src/Verify.Tests/Naming/NamerTests.cs#L357-L362' title='Snippet source file'>snippet source</a> | <a href='#snippet-accessnamerruntimeandversion' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->


## DerivePathInfo

`DerivePathInfo` allows the storage directory of `.verified.` files to be customized based on the current context. The contextual parameters are parameters passed are as follows:

 * `sourceFile`: The full path to the file that the test existed in at compile time.
 * `projectDirectory`: The directory that the project existed in at compile time.
 * `type`: The class the test method exists in.
 * `method`: The test method.

Return null to any of the values to use the standard behavior. The returned path can be relative to the directory sourceFile exists in.

`DerivePathInfo` can also be useful when deriving the storage directory on a [build server](build-server.md#custom-directory-and-file-name)

For example to place all `.verified.` files in a `{ProjectDirectory}\Snapshots` the following could be used:


### Xunit

<!-- snippet: DerivePathInfoXUnit -->
<a id='snippet-derivepathinfoxunit'></a>
```cs
Verifier.DerivePathInfo(
    (sourceFile, projectDirectory, type, method) => new(
        directory: Path.Combine(projectDirectory, "Snapshots"),
        typeName: type.Name,
        methodName: method.Name));
```
<sup><a href='/src/Verify.Xunit.Tests/Tests.cs#L9-L17' title='Snippet source file'>snippet source</a> | <a href='#snippet-derivepathinfoxunit' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->


### NUnit

<!-- snippet: DerivePathInfoNunit -->
<a id='snippet-derivepathinfonunit'></a>
```cs
Verifier.DerivePathInfo(
    (sourceFile, projectDirectory, type, method) => new(
        directory: Path.Combine(projectDirectory, "Snapshots"),
        typeName: type.Name,
        methodName: method.Name));
```
<sup><a href='/src/Verify.NUnit.Tests/Tests.cs#L9-L17' title='Snippet source file'>snippet source</a> | <a href='#snippet-derivepathinfonunit' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->


### MSTest

<!-- snippet: DerivePathInfoMSTest -->
<a id='snippet-derivepathinfomstest'></a>
```cs
DerivePathInfo(
    (sourceFile, projectDirectory, type, method) => new(
        directory: Path.Combine(projectDirectory, "Snapshots"),
        typeName: type.Name,
        methodName: method.Name));
```
<sup><a href='/src/Verify.MSTest.Tests/Tests.cs#L10-L18' title='Snippet source file'>snippet source</a> | <a href='#snippet-derivepathinfomstest' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->


### Expecto

<!-- snippet: DerivePathInfoExpecto -->
<a id='snippet-derivepathinfoexpecto'></a>
```cs
Verifier.DerivePathInfo(
    (sourceFile, projectDirectory, type, method) => new(
        directory: Path.Combine(projectDirectory, "Snapshots"),
        typeName: type,
        methodName: method));
```
<sup><a href='/src/Verify.Expecto.Tests/Tests.cs#L8-L16' title='Snippet source file'>snippet source</a> | <a href='#snippet-derivepathinfoexpecto' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->


### As a nuget

A `DerivePathInfo` convention can be shipped as a NuGet, for example [Spectre.Verify.Extensions](https://github.com/spectresystems/spectre.verify.extensions) which adds an attribute driven file naming convention to Verify.


### Default DerivePathInfo

<!-- snippet: defaultDerivePathInfo -->
<a id='snippet-defaultderivepathinfo'></a>
```cs
public static PathInfo DeriveDefault(
    string sourceFile,
    string projectDirectory,
    Type type,
    MethodInfo method) =>
    new(
        directory: IoHelpers.ResolveDirectoryFromSourceFile(sourceFile),
        typeName: type.NameWithParent(),
        methodName: method.Name);
```
<sup><a href='/src/Verify/DerivePaths/PathInfo.cs#L23-L35' title='Snippet source file'>snippet source</a> | <a href='#snippet-defaultderivepathinfo' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->

Where `NameWithParent` is

<!-- snippet: NameWithParent -->
<a id='snippet-namewithparent'></a>
```cs
public static string NameWithParent(this Type type)
{
    if (type.IsNested)
    {
        return $"{type.ReflectedType!.Name}.{type.Name}";
    }

    return type.Name;
}
```
<sup><a href='/src/Verify/Extensions.cs#L100-L112' title='Snippet source file'>snippet source</a> | <a href='#snippet-namewithparent' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->


### UseProjectRelativeDirectory

`Verifier.UseProjectRelativeDirectory` is a wrapper around `DerivePathInfo` that stores all `.verified.` files in a directory relative to the project directory.

For example to place all `.verified.` files in a `{ProjectDirectory}\Snapshots` the following could be used:

```
Verifier.UseProjectRelativeDirectory("Snapshots");
```


## DisableRequireUniquePrefix

Snapshot file names have to be unique. If a duplicate name is used, then an exception will be throw. This is mostly caused by a conflicting combination of `Verifier.DerivePathInfo()`, `UseMethodName.UseDirectory()`, `UseMethodName.UseTypeName()`, and `UseMethodName.UseMethodName()`. If that's not the case, and having multiple identical prefixes is acceptable, then call `VerifierSettings.DisableRequireUniquePrefix()` to disable this uniqueness validation


## UseUniqueDirectory

An alternative to the "unique file name in the current test directory".

This approach uses "a unique directory in the current test directory".

Useful when many test produce many files, and it is desirable to have them grouped in a directory.

The file format is:

```
{CurrentDirectory}/{TestClassName}.{TestMethodName}_{Parameters}_{UniqueFor1}_{UniqueFor2}_{UniqueForX}/{targetName}.verified.{extension}
```

<!-- snippet: UseUniqueDirectory -->
<a id='snippet-useuniquedirectory'></a>
```cs
var settings = new VerifySettings();
settings.UseUniqueDirectory();
await Verify("TheValue", settings);
```
<sup><a href='/src/Verify.Tests/Naming/NamerTests.cs#L223-L229' title='Snippet source file'>snippet source</a> | <a href='#snippet-useuniquedirectory' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->


### UseSplitModeForUniqueDirectory

`UseSplitModeForUniqueDirectory` is a global option that changes the behavior of all `UseUniqueDirectory` uses.

The `received` and `verified` are split and each exist in their own directory.

The file format is:

For received files:

```
{CurrentDirectory}/{TestClassName}.{TestMethodName}_{Parameters}_{UniqueFor1}_{UniqueFor2}_{UniqueForX}.received/{targetName}.{extension}
```

For verified files:

```
{CurrentDirectory}/{TestClassName}.{TestMethodName}_{Parameters}_{UniqueFor1}_{UniqueFor2}_{UniqueForX}.verified/{targetName}.{extension}
```

<!-- snippet: UseSplitModeForUniqueDirectory -->
<a id='snippet-usesplitmodeforuniquedirectory'></a>
```cs
public static class ModuleInitializer
{
    [ModuleInitializer]
    public static void Init() =>
        VerifierSettings.UseSplitModeForUniqueDirectory();
}
```
<sup><a href='/src/ModuleInitDocs/UseSplitModeForUniqueDirectory.cs#L3-L12' title='Snippet source file'>snippet source</a> | <a href='#snippet-usesplitmodeforuniquedirectory' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->

**Also exclude `*.received/` from source control.**

eg. add the following to `.gitignore`

`*.received/`


## Received and multi-targetting

When a test project uses more than one `TargetFrameworks` (eg `<TargetFrameworks>net48;net7.0</TargetFrameworks>`) the runtime and version will be always be added as a uniqueness to the received file. This prevents file locking contenction when the tests from both target framework run in parallel.
