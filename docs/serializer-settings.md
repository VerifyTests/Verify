<!--
GENERATED FILE - DO NOT EDIT
This file was generated by [MarkdownSnippets](https://github.com/SimonCropp/MarkdownSnippets).
Source File: /docs/mdsource/serializer-settings.source.md
To change this file edit the source file and then run MarkdownSnippets.
-->

# Serializer settings

Serialization settings can be customized at three levels:

 * Method: Will run the verification in the current test method.
 * Class: Will run for all verifications in all test methods for a test class.
 * Global: Will run for test methods on all tests.


## Not valid json

Note that the output is technically not valid json.

 * Names and values are not quoted.
 * Newlines are not escaped.

The reason for these is that it makes approval files cleaner and easier to read and visualize/understand differences.


### UseStrictJson

To use strict json call `VerifierSettings.UseStrictJson`:

<!-- snippet: UseStrictJson -->
<a id='snippet-usestrictjson'></a>
```cs
VerifierSettings.UseStrictJson();
```
<sup><a href='/src/StrictJsonTests/Tests.cs#L6-L10' title='Snippet source file'>snippet source</a> | <a href='#snippet-usestrictjson' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->

Then this result in 

 * The default `.received.` and `.verified.` extensions for serialized verification to be `.json`.
 * `JsonTextWriter.QuoteChar` to be `"`.
 * `JsonTextWriter.QuoteName` to be `true`.

Then when an object is verified:

<!-- snippet: UseStrictJsonVerify -->
<a id='snippet-usestrictjsonverify'></a>
```cs
var target = new TheTarget
{
    Value = "Foo"
};
await Verify(target);
```
<sup><a href='/src/StrictJsonTests/Tests.cs#L66-L74' title='Snippet source file'>snippet source</a> | <a href='#snippet-usestrictjsonverify' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->

The resulting file will be:

<!-- snippet: Tests.Object.verified.json -->
<a id='snippet-Tests.Object.verified.json'></a>
```json
{
  "Value": "Foo"
}
```
<sup><a href='/src/StrictJsonTests/Tests.Object.verified.json#L1-L3' title='Snippet source file'>snippet source</a> | <a href='#snippet-Tests.Object.verified.json' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->


## Default settings

The default `JsonSerializerSettings` are:

<!-- snippet: defaultSerialization -->
<a id='snippet-defaultserialization'></a>
```cs
var settings = new JsonSerializerSettings
{
    Formatting = Formatting.Indented,
    ReferenceLoopHandling = ReferenceLoopHandling.Ignore,
    DefaultValueHandling = DefaultValueHandling.Ignore,
    Culture = CultureInfo.InvariantCulture
};
```
<sup><a href='/src/Verify/Serialization/SerializationSettings.cs#L81-L91' title='Snippet source file'>snippet source</a> | <a href='#snippet-defaultserialization' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->


### Modify Defaults


#### Globally

<!-- snippet: AddExtraSettingsGlobal -->
<a id='snippet-addextrasettingsglobal'></a>
```cs
VerifierSettings
    .AddExtraSettings(_ =>
        _.TypeNameHandling = TypeNameHandling.All);
```
<sup><a href='/src/Verify.Tests/Serialization/SerializationTests.cs#L318-L324' title='Snippet source file'>snippet source</a> | <a href='#snippet-addextrasettingsglobal' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->


#### On Settings

<!-- snippet: AddExtraSettings -->
<a id='snippet-addextrasettings'></a>
```cs
[Fact]
public Task AddExtraSettings()
{
    var settings = new VerifySettings();
    settings
        .AddExtraSettings(
            _ => _.Error += (sender, args)
                => Console.WriteLine(args.ErrorContext.Member));
    return Verify("Value", settings);
}
```
<sup><a href='/src/Verify.Tests/Serialization/SerializationTests.cs#L289-L302' title='Snippet source file'>snippet source</a> | <a href='#snippet-addextrasettings' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->


#### On Settings Fluent

<!-- snippet: AddExtraSettingsFluent -->
<a id='snippet-addextrasettingsfluent'></a>
```cs
[Fact]
public Task AddExtraSettingsFluent() =>
    Verify("Value")
        .AddExtraSettings(
            _ => _.Error += (sender, args)
                => Console.WriteLine(args.ErrorContext.Member));
```
<sup><a href='/src/Verify.Tests/Serialization/SerializationTests.cs#L304-L313' title='Snippet source file'>snippet source</a> | <a href='#snippet-addextrasettingsfluent' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->


## QuoteName is false

[JsonTextWriter.QuoteName](https://www.newtonsoft.com/json/help/html/P_Newtonsoft_Json_JsonTextWriter_QuoteName.htm) is set to false. The reason for this is that it makes approval files cleaner and easier to read and visualize/understand differences.


## Empty collections are ignored

By default empty collections are ignored during verification.

To disable this behavior globally use:

<!-- snippet: DontIgnoreEmptyCollections -->
<a id='snippet-dontignoreemptycollections'></a>
```cs
VerifierSettings.DontIgnoreEmptyCollections();
```
<sup><a href='/src/Verify.Tests/Serialization/SerializationTests.cs#L815-L819' title='Snippet source file'>snippet source</a> | <a href='#snippet-dontignoreemptycollections' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->


## Guids are scrubbed

By default guids are sanitized during verification. This is done by finding each guid and taking a counter based that that specific guid. That counter is then used replace the guid values. This allows for repeatable tests when guid values are changing.

<!-- snippet: guid -->
<a id='snippet-guid'></a>
```cs
var guid = Guid.NewGuid();
var target = new GuidTarget
{
    Guid = guid,
    GuidNullable = guid,
    GuidString = guid.ToString(),
    OtherGuid = Guid.NewGuid()
};

await Verify(target);
```
<sup><a href='/src/Verify.Tests/Serialization/SerializationTests.cs#L1136-L1149' title='Snippet source file'>snippet source</a> | <a href='#snippet-guid' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->

Results in the following:

<!-- snippet: SerializationTests.ShouldReUseGuid.verified.txt -->
<a id='snippet-SerializationTests.ShouldReUseGuid.verified.txt'></a>
```txt
{
  Guid: Guid_1,
  GuidNullable: Guid_1,
  GuidString: Guid_1,
  OtherGuid: Guid_2
}
```
<sup><a href='/src/Verify.Tests/Serialization/SerializationTests.ShouldReUseGuid.verified.txt#L1-L6' title='Snippet source file'>snippet source</a> | <a href='#snippet-SerializationTests.ShouldReUseGuid.verified.txt' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->

Strings containing inline Guids can also be scrubbed. To enable this behavior, use:

<!-- snippet: ScrubInlineGuids -->
<a id='snippet-scrubinlineguids'></a>
```cs
VerifierSettings.ScrubInlineGuids();
```
<sup><a href='/src/Verify.Tests/Serialization/SerializationTests.cs#L851-L855' title='Snippet source file'>snippet source</a> | <a href='#snippet-scrubinlineguids' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->


### Disable

To disable this behavior use:

<!-- snippet: DontScrubGuids -->
<a id='snippet-dontscrubguids'></a>
```cs
var settings = new VerifySettings();
settings.DontScrubGuids();
await Verify(target, settings);
```
<sup><a href='/src/Verify.Tests/Serialization/SerializationTests.cs#L355-L361' title='Snippet source file'>snippet source</a> | <a href='#snippet-dontscrubguids' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->

Or with the fluent api:

<!-- snippet: DontScrubGuidsFluent -->
<a id='snippet-dontscrubguidsfluent'></a>
```cs
await Verify(target)
    .DontScrubGuids();
```
<sup><a href='/src/Verify.Tests/Serialization/SerializationTests.cs#L369-L374' title='Snippet source file'>snippet source</a> | <a href='#snippet-dontscrubguidsfluent' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->

To disable this behavior globally use:

<!-- snippet: DontScrubGuidsGlobal -->
<a id='snippet-dontscrubguidsglobal'></a>
```cs
VerifierSettings.DontScrubGuids();
```
<sup><a href='/src/Verify.Tests/Serialization/SerializationTests.cs#L824-L828' title='Snippet source file'>snippet source</a> | <a href='#snippet-dontscrubguidsglobal' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->


## Dates are scrubbed

By default dates (`DateTime` and `DateTimeOffset`) are sanitized during verification. This is done by finding each date and taking a counter based that that specific date. That counter is then used replace the date values. This allows for repeatable tests when date values are changing.

<!-- snippet: Date -->
<a id='snippet-date'></a>
```cs
var dateTime = DateTime.Now;
var dateTimeOffset = DateTimeOffset.Now;
var target = new DateTimeTarget
{
    DateTime = dateTime,
    DateOnly = new(dateTime.Year, dateTime.Month, dateTime.Day),
    DateOnlyNullable = new(dateTime.Year, dateTime.Month, dateTime.Day),
    DateOnlyString = new DateOnly(dateTime.Year, dateTime.Month, dateTime.Day).ToString(),
    DateTimeNullable = dateTime,
    DateTimeString = dateTime.ToString("F"),
    DateTimeOffset = dateTimeOffset,
    DateTimeOffsetNullable = dateTimeOffset,
    DateTimeOffsetString = dateTimeOffset.ToString("F")
};

await Verify(target);
```
<sup><a href='/src/Verify.Tests/Serialization/SerializationTests.cs#L556-L575' title='Snippet source file'>snippet source</a> | <a href='#snippet-date' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->

Results in the following:

<!-- snippet: SerializationTests.ShouldReUseDatetime.verified.txt -->
<a id='snippet-SerializationTests.ShouldReUseDatetime.verified.txt'></a>
```txt
{
  DateTime: DateTime_1,
  DateTimeNullable: DateTime_1,
  DateOnly: Date_1,
  DateOnlyNullable: Date_1,
  DateTimeOffset: DateTimeOffset_1,
  DateTimeOffsetNullable: DateTimeOffset_1,
  DateTimeString: DateTimeOffset_2,
  DateTimeOffsetString: DateTimeOffset_2,
  DateOnlyString: Date_1
}
```
<sup><a href='/src/Verify.Tests/Serialization/SerializationTests.ShouldReUseDatetime.verified.txt#L1-L11' title='Snippet source file'>snippet source</a> | <a href='#snippet-SerializationTests.ShouldReUseDatetime.verified.txt' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->

To disable this behavior use:

<!-- snippet: DontScrubDateTimes -->
<a id='snippet-dontscrubdatetimes'></a>
```cs
var target = new
{
    Date = DateTime.Now
};

var settings = new VerifySettings();
settings.DontScrubDateTimes();

return Verify(target, settings);
```
<sup><a href='/src/Verify.Tests/Serialization/SerializationTests.cs#L881-L893' title='Snippet source file'>snippet source</a> | <a href='#snippet-dontscrubdatetimes' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->

Or using the fluent api use:

<!-- snippet: DontScrubDateTimesFluent -->
<a id='snippet-dontscrubdatetimesfluent'></a>
```cs
var target = new
{
    Date = DateTime.Now
};

return Verify(target)
    .DontScrubDateTimes();
```
<sup><a href='/src/Verify.Tests/Serialization/SerializationTests.cs#L898-L908' title='Snippet source file'>snippet source</a> | <a href='#snippet-dontscrubdatetimesfluent' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->

Or globally use:

<!-- snippet: DontScrubDateTimesGlobal -->
<a id='snippet-dontscrubdatetimesglobal'></a>
```cs
VerifierSettings.DontScrubDateTimes();
```
<sup><a href='/src/Verify.Tests/Serialization/SerializationTests.cs#L913-L917' title='Snippet source file'>snippet source</a> | <a href='#snippet-dontscrubdatetimesglobal' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->


## Change defaults at the verification level

`DateTime`, `DateTimeOffset`, `Guid`, `bool`, and empty collection behavior can also be controlled at the verification level: 

<!-- snippet: ChangeDefaultsPerVerification -->
<a id='snippet-changedefaultsperverification'></a>
```cs
var settings = new VerifySettings();
settings.DontIgnoreEmptyCollections();
settings.DontScrubGuids();
settings.DontScrubDateTimes();
await Verify(target, settings);
```
<sup><a href='/src/Verify.MSTest.Tests/VerifyObjectSamples.cs#L13-L21' title='Snippet source file'>snippet source</a> | <a href='#snippet-changedefaultsperverification' title='Start of snippet'>anchor</a></sup>
<a id='snippet-changedefaultsperverification-1'></a>
```cs
await Verify(target)
    .DontIgnoreEmptyCollections()
    .DontScrubGuids()
    .DontScrubDateTimes();
```
<sup><a href='/src/Verify.MSTest.Tests/VerifyObjectSamples.cs#L23-L30' title='Snippet source file'>snippet source</a> | <a href='#snippet-changedefaultsperverification-1' title='Start of snippet'>anchor</a></sup>
<a id='snippet-changedefaultsperverification-2'></a>
```cs
await Verify(target)
    .DontIgnoreEmptyCollections()
    .DontScrubGuids()
    .DontScrubDateTimes();
```
<sup><a href='/src/Verify.NUnit.Tests/VerifyObjectSamples.cs#L11-L18' title='Snippet source file'>snippet source</a> | <a href='#snippet-changedefaultsperverification-2' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->


## Changing Json.NET settings

Extra Json.NET settings can be made:


### Globally

<!-- snippet: ExtraSettingsGlobal -->
<a id='snippet-extrasettingsglobal'></a>
```cs
VerifierSettings.AddExtraSettings(
    _ =>
    {
        _.TypeNameHandling = TypeNameHandling.All;
    });
```
<sup><a href='/src/Verify.Tests/Snippets/Snippets.cs#L115-L123' title='Snippet source file'>snippet source</a> | <a href='#snippet-extrasettingsglobal' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->


### Instance

<!-- snippet: ExtraSettingsInstance -->
<a id='snippet-extrasettingsinstance'></a>
```cs
var settings = new VerifySettings();
settings.AddExtraSettings(
    _ =>
    {
        _.TypeNameHandling = TypeNameHandling.All;
    });
```
<sup><a href='/src/Verify.Tests/Snippets/Snippets.cs#L125-L134' title='Snippet source file'>snippet source</a> | <a href='#snippet-extrasettingsinstance' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->


### Json.NET Converter

One common use case is to register a custom [JsonConverter](https://www.newtonsoft.com/json/help/html/CustomJsonConverter.htm). As only writing is required, to help with this there is `WriteOnlyJsonConverter`, and `WriteOnlyJsonConverter<T>`.

<!-- snippet: CompanyConverter -->
<a id='snippet-companyconverter'></a>
```cs
class CompanyConverter :
    WriteOnlyJsonConverter<Company>
{
    public override void Write(VerifyJsonWriter writer, Company company) =>
        writer.WriteMember(company, company.Name, "Name");
}
```
<sup><a href='/src/Verify.Tests/Snippets/Snippets.cs#L150-L159' title='Snippet source file'>snippet source</a> | <a href='#snippet-companyconverter' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->

<!-- snippet: JsonConverter -->
<a id='snippet-jsonconverter'></a>
```cs
VerifierSettings.AddExtraSettings(
    _ =>
    {
        _.Converters.Add(new CompanyConverter());
    });
```
<sup><a href='/src/Verify.Tests/Snippets/Snippets.cs#L139-L147' title='Snippet source file'>snippet source</a> | <a href='#snippet-jsonconverter' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->


#### VerifyJsonWriter

`VerifyJsonWriter` exposes the following members:

 * `Counter` property that gives programmatic access to the counting behavior used by [Guid](#guids-are-scrubbed), [Date](#dates-are-scrubbed), and [Id](#numeric-ids-are-scrubbed) scrubbing.
 * `Serializer` property that exposes the current `JsonSerializer`.
 * `Serialize(object value)` is a convenience method that calls `JsonSerializer.Serialize` passing in the writer instance and the `value` parameter.
 * `WriteProperty<T, TMember>(T target, TMember value, string name)` method that writes a property name and value while respecting other custom serialization settings eg [member converters](#converting-a-member), [ignore rules](#ignoring-a-type) etc.


## Scoped settings

<!-- snippet: ScopedSerializer -->
<a id='snippet-scopedserializer'></a>
```cs
[Fact]
public Task ScopedSerializer()
{
    var person = new Person
    {
        GivenNames = "John",
        FamilyName = "Smith"
    };
    var settings = new VerifySettings();
    settings.AddExtraSettings(_ => _.TypeNameHandling = TypeNameHandling.All);
    return Verify(person, settings);
}

[Fact]
public Task ScopedSerializerFluent()
{
    var person = new Person
    {
        GivenNames = "John",
        FamilyName = "Smith"
    };
    return Verify(person)
        .AddExtraSettings(_ => _.TypeNameHandling = TypeNameHandling.All);
}
```
<sup><a href='/src/Verify.Tests/Serialization/SerializationTests.cs#L2433-L2460' title='Snippet source file'>snippet source</a> | <a href='#snippet-scopedserializer' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->

Result:

<!-- snippet: Verify.Xunit.Tests/VerifyObjectSamples.ScopedSerializer.verified.txt -->
<a id='snippet-Verify.Xunit.Tests/VerifyObjectSamples.ScopedSerializer.verified.txt'></a>
```txt
{
  $type: VerifyObjectSamples.Person,
  GivenNames: John,
  FamilyName: Smith
}
```
<sup><a href='/src/Verify.Xunit.Tests/VerifyObjectSamples.ScopedSerializer.verified.txt#L1-L5' title='Snippet source file'>snippet source</a> | <a href='#snippet-Verify.Xunit.Tests/VerifyObjectSamples.ScopedSerializer.verified.txt' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->


## Ignoring a type

To ignore all members that match a certain type:

<!-- snippet: AddIgnoreType -->
<a id='snippet-addignoretype'></a>
```cs
[Fact]
public Task IgnoreType()
{
    var target = new IgnoreTypeTarget
    {
        ToIgnore = new()
        {
            Property = "Value"
        },
        ToIgnoreNullable = new()
        {
            Property = "Value"
        },
        ToIgnoreByInterface = new()
        {
            Property = "Value"
        },
        ToIgnoreByBase = new()
        {
            Property = "Value"
        },
        ToIgnoreByBaseGeneric = new()
        {
            Property = "Value"
        },
        ToIgnoreByType = new()
        {
            Property = "Value"
        },
        ToInclude = new()
        {
            Property = "Value"
        },
        ToIncludeNullable = new()
        {
            Property = "Value"
        },
        ToIgnoreStruct = new("Value"),
        ToIgnoreStructNullable = new("Value"),
        ToIncludeStruct = new("Value"),
        ToIncludeStructNullable = new("Value")
    };
    var settings = new VerifySettings();
    settings.IgnoreMembersWithType<ToIgnore>();
    settings.IgnoreMembersWithType<ToIgnoreByType>();
    settings.IgnoreMembersWithType<InterfaceToIgnore>();
    settings.IgnoreMembersWithType<BaseToIgnore>();
    settings.IgnoreMembersWithType(typeof(BaseToIgnoreGeneric<>));
    settings.IgnoreMembersWithType<ToIgnoreStruct>();
    return Verify(target, settings);
}

[Fact]
public Task IgnoreTypeFluent()
{
    var target = new IgnoreTypeTarget
    {
        ToIgnore = new()
        {
            Property = "Value"
        },
        ToIgnoreNullable = new()
        {
            Property = "Value"
        },
        ToIgnoreByInterface = new()
        {
            Property = "Value"
        },
        ToIgnoreByBase = new()
        {
            Property = "Value"
        },
        ToIgnoreByBaseGeneric = new()
        {
            Property = "Value"
        },
        ToIgnoreByType = new()
        {
            Property = "Value"
        },
        ToInclude = new()
        {
            Property = "Value"
        },
        ToIncludeNullable = new()
        {
            Property = "Value"
        },
        ToIgnoreStruct = new("Value"),
        ToIgnoreStructNullable = new("Value"),
        ToIncludeStruct = new("Value"),
        ToIncludeStructNullable = new("Value")
    };
    return Verify(target)
        .IgnoreMembersWithType<ToIgnore>()
        .IgnoreMembersWithType<ToIgnoreByType>()
        .IgnoreMembersWithType<InterfaceToIgnore>()
        .IgnoreMembersWithType<BaseToIgnore>()
        .IgnoreMembersWithType(typeof(BaseToIgnoreGeneric<>))
        .IgnoreMembersWithType<ToIgnoreStruct>();
}
```
<sup><a href='/src/Verify.Tests/Serialization/SerializationTests.cs#L1673-L1778' title='Snippet source file'>snippet source</a> | <a href='#snippet-addignoretype' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->

Or globally:

<!-- snippet: AddIgnoreTypeGlobal -->
<a id='snippet-addignoretypeglobal'></a>
```cs
VerifierSettings.IgnoreMembersWithType<ToIgnore>();
```
<sup><a href='/src/Verify.Tests/Serialization/SerializationTests.cs#L1666-L1670' title='Snippet source file'>snippet source</a> | <a href='#snippet-addignoretypeglobal' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->

Result:

<!-- snippet: SerializationTests.IgnoreType.verified.txt -->
<a id='snippet-SerializationTests.IgnoreType.verified.txt'></a>
```txt
{
  ToInclude: {
    Property: Value
  },
  ToIncludeNullable: {
    Property: Value
  },
  ToIncludeStruct: {
    Property: Value
  },
  ToIncludeStructNullable: {
    Property: Value
  }
}
```
<sup><a href='/src/Verify.Tests/Serialization/SerializationTests.IgnoreType.verified.txt#L1-L14' title='Snippet source file'>snippet source</a> | <a href='#snippet-SerializationTests.IgnoreType.verified.txt' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->


## Ignoring a instance

To ignore instances of a type based on delegate:

<!-- snippet: AddIgnoreInstance -->
<a id='snippet-addignoreinstance'></a>
```cs
[Fact]
public Task AddIgnoreInstance()
{
    var target = new IgnoreInstanceTarget
    {
        ToIgnore = new()
        {
            Property = "Ignore"
        },
        ToInclude = new()
        {
            Property = "Include"
        }
    };
    var settings = new VerifySettings();
    settings.IgnoreInstance<Instance>(_ => _.Property == "Ignore");
    return Verify(target, settings);
}

[Fact]
public Task AddIgnoreInstanceFluent()
{
    var target = new IgnoreInstanceTarget
    {
        ToIgnore = new()
        {
            Property = "Ignore"
        },
        ToInclude = new()
        {
            Property = "Include"
        }
    };
    return Verify(target)
        .IgnoreInstance<Instance>(_ => _.Property == "Ignore");
}
```
<sup><a href='/src/Verify.Tests/Serialization/SerializationTests.cs#L1594-L1633' title='Snippet source file'>snippet source</a> | <a href='#snippet-addignoreinstance' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->

Or globally:

<!-- snippet: AddIgnoreInstanceGlobal -->
<a id='snippet-addignoreinstanceglobal'></a>
```cs
VerifierSettings.IgnoreInstance<Instance>(_ => _.Property == "Ignore");
```
<sup><a href='/src/Verify.Tests/Serialization/SerializationTests.cs#L1587-L1591' title='Snippet source file'>snippet source</a> | <a href='#snippet-addignoreinstanceglobal' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->

Result:

<!-- snippet: SerializationTests.AddIgnoreInstance.verified.txt -->
<a id='snippet-SerializationTests.AddIgnoreInstance.verified.txt'></a>
```txt
{
  ToInclude: {
    Property: Include
  }
}
```
<sup><a href='/src/Verify.Tests/Serialization/SerializationTests.AddIgnoreInstance.verified.txt#L1-L5' title='Snippet source file'>snippet source</a> | <a href='#snippet-SerializationTests.AddIgnoreInstance.verified.txt' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->


## Obsolete members ignored

Members with an [ObsoleteAttribute](https://docs.microsoft.com/en-us/dotnet/api/system.obsoleteattribute) are ignored:

<!-- snippet: WithObsoleteProp -->
<a id='snippet-withobsoleteprop'></a>
```cs
class WithObsolete
{
    [Obsolete] public string ObsoleteProperty { get; set; }

    public string OtherProperty { get; set; }
}

[Fact]
public Task WithObsoleteProp()
{
    var target = new WithObsolete
    {
        ObsoleteProperty = "value1",
        OtherProperty = "value2"
    };
    return Verify(target);
}
```
<sup><a href='/src/Verify.Tests/Serialization/SerializationTests.cs#L2399-L2419' title='Snippet source file'>snippet source</a> | <a href='#snippet-withobsoleteprop' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->

Result:

<!-- snippet: SerializationTests.WithObsoleteProp.verified.txt -->
<a id='snippet-SerializationTests.WithObsoleteProp.verified.txt'></a>
```txt
{
  OtherProperty: value2
}
```
<sup><a href='/src/Verify.Tests/Serialization/SerializationTests.WithObsoleteProp.verified.txt#L1-L3' title='Snippet source file'>snippet source</a> | <a href='#snippet-SerializationTests.WithObsoleteProp.verified.txt' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->


### Including Obsolete members

Obsolete members can be included using `IncludeObsoletes`:

<!-- snippet: WithObsoletePropIncluded -->
<a id='snippet-withobsoletepropincluded'></a>
```cs
[Fact]
public Task WithObsoletePropIncluded()
{
    var target = new WithObsolete
    {
        ObsoleteProperty = "value1",
        OtherProperty = "value2"
    };
    var settings = new VerifySettings();
    settings.IncludeObsoletes();
    return Verify(target, settings);
}

[Fact]
public Task WithObsoletePropIncludedFluent()
{
    var target = new WithObsolete
    {
        ObsoleteProperty = "value1",
        OtherProperty = "value2"
    };
    return Verify(target)
        .IncludeObsoletes();
}
```
<sup><a href='/src/Verify.Tests/Serialization/SerializationTests.cs#L2370-L2397' title='Snippet source file'>snippet source</a> | <a href='#snippet-withobsoletepropincluded' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->

Or globally:

<!-- snippet: WithObsoletePropIncludedGlobally -->
<a id='snippet-withobsoletepropincludedglobally'></a>
```cs
VerifierSettings.IncludeObsoletes();
```
<sup><a href='/src/Verify.Tests/Serialization/SerializationTests.cs#L2363-L2367' title='Snippet source file'>snippet source</a> | <a href='#snippet-withobsoletepropincludedglobally' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->

Result:

<!-- snippet: SerializationTests.WithObsoletePropIncluded.verified.txt -->
<a id='snippet-SerializationTests.WithObsoletePropIncluded.verified.txt'></a>
```txt
{
  ObsoleteProperty: value1,
  OtherProperty: value2
}
```
<sup><a href='/src/Verify.Tests/Serialization/SerializationTests.WithObsoletePropIncluded.verified.txt#L1-L4' title='Snippet source file'>snippet source</a> | <a href='#snippet-SerializationTests.WithObsoletePropIncluded.verified.txt' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->


## Ignore member by expressions

To ignore members of a certain type using an expression:

<!-- snippet: IgnoreMemberByExpression -->
<a id='snippet-ignorememberbyexpression'></a>
```cs
[Fact]
public Task IgnoreMemberByExpression()
{
    var target = new IgnoreExplicitTarget
    {
        Include = "Value",
        Field = "Value",
        Property = "Value",
        PropertyWithPropertyName = "Value"
    };
    var settings = new VerifySettings();
    settings.IgnoreMembers<IgnoreExplicitTarget>(
        _ => _.Property,
        _ => _.PropertyWithPropertyName,
        _ => _.Field,
        _ => _.GetOnlyProperty,
        _ => _.PropertyThatThrows);
    return Verify(target, settings);
}

[Fact]
public Task IgnoreMemberByExpressionFluent()
{
    var target = new IgnoreExplicitTarget
    {
        Include = "Value",
        Field = "Value",
        Property = "Value"
    };
    return Verify(target)
        .IgnoreMembers<IgnoreExplicitTarget>(
            _ => _.Property,
            _ => _.Field,
            _ => _.GetOnlyProperty,
            _ => _.PropertyThatThrows);
}
```
<sup><a href='/src/Verify.Tests/Serialization/SerializationTests.cs#L1958-L1997' title='Snippet source file'>snippet source</a> | <a href='#snippet-ignorememberbyexpression' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->

Or globally

<!-- snippet: IgnoreMemberByExpressionGlobal -->
<a id='snippet-ignorememberbyexpressionglobal'></a>
```cs
VerifierSettings.IgnoreMembers<IgnoreExplicitTarget>(
    _ => _.Property,
    _ => _.PropertyWithPropertyName,
    _ => _.Field,
    _ => _.GetOnlyProperty,
    _ => _.PropertyThatThrows);
```
<sup><a href='/src/Verify.Tests/Serialization/SerializationTests.cs#L1946-L1955' title='Snippet source file'>snippet source</a> | <a href='#snippet-ignorememberbyexpressionglobal' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->

Result:

<!-- snippet: SerializationTests.IgnoreMemberByExpression.verified.txt -->
<a id='snippet-SerializationTests.IgnoreMemberByExpression.verified.txt'></a>
```txt
{
  Include: Value
}
```
<sup><a href='/src/Verify.Tests/Serialization/SerializationTests.IgnoreMemberByExpression.verified.txt#L1-L3' title='Snippet source file'>snippet source</a> | <a href='#snippet-SerializationTests.IgnoreMemberByExpression.verified.txt' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->


## Ignore member by name

To ignore members of a certain type using type and name:

<!-- snippet: IgnoreMemberByName -->
<a id='snippet-ignorememberbyname'></a>
```cs
[Fact]
public Task IgnoreMemberByName()
{
    var target = new IgnoreExplicitTarget
    {
        Include = "Value",
        Field = "Value",
        Property = "Value",
        PropertyByName = "Value"
    };
    var settings = new VerifySettings();

    // For all types
    settings.IgnoreMember("PropertyByName");

    // For a specific type
    settings.IgnoreMember(typeof(IgnoreExplicitTarget), "Property");

    // For a specific type generic
    settings.IgnoreMember<IgnoreExplicitTarget>("Field");

    // For a specific type with expression
    settings.IgnoreMember<IgnoreExplicitTarget>(_ => _.PropertyThatThrows);

    return Verify(target, settings);
}

[Fact]
public Task IgnoreMemberByNameFluent()
{
    var target = new IgnoreExplicitTarget
    {
        Include = "Value",
        Field = "Value",
        Property = "Value",
        PropertyByName = "Value"
    };
    return Verify(target)
        // For all types
        .IgnoreMember("PropertyByName")

        // For a specific type
        .IgnoreMember(typeof(IgnoreExplicitTarget), "Property")

        // For a specific type generic
        .IgnoreMember<IgnoreExplicitTarget>("Field")

        // For a specific type with expression
        .IgnoreMember<IgnoreExplicitTarget>(_ => _.PropertyThatThrows);
}
```
<sup><a href='/src/Verify.Tests/Serialization/SerializationTests.cs#L2050-L2103' title='Snippet source file'>snippet source</a> | <a href='#snippet-ignorememberbyname' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->

Or globally:

<!-- snippet: IgnoreMemberByNameGlobal -->
<a id='snippet-ignorememberbynameglobal'></a>
```cs
// For all types
VerifierSettings.IgnoreMember("PropertyByName");

// For a specific type
VerifierSettings.IgnoreMember(typeof(IgnoreExplicitTarget), "Property");

// For a specific type generic
VerifierSettings.IgnoreMember<IgnoreExplicitTarget>("Field");

// For a specific type with expression
VerifierSettings.IgnoreMember<IgnoreExplicitTarget>(_ => _.PropertyThatThrows);
```
<sup><a href='/src/Verify.Tests/Serialization/SerializationTests.cs#L2033-L2047' title='Snippet source file'>snippet source</a> | <a href='#snippet-ignorememberbynameglobal' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->

Result:

<!-- snippet: SerializationTests.IgnoreMemberByName.verified.txt -->
<a id='snippet-SerializationTests.IgnoreMemberByName.verified.txt'></a>
```txt
{
  Include: Value,
  GetOnlyProperty: asd
}
```
<sup><a href='/src/Verify.Tests/Serialization/SerializationTests.IgnoreMemberByName.verified.txt#L1-L4' title='Snippet source file'>snippet source</a> | <a href='#snippet-SerializationTests.IgnoreMemberByName.verified.txt' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->


## Members that throw

Members that throw exceptions can be excluded from serialization based on the exception type or properties.

By default members that throw `NotImplementedException` or `NotSupportedException` are ignored.

Note that this is global for all members on all types.

Ignore by exception type:

<!-- snippet: IgnoreMembersThatThrow -->
<a id='snippet-ignoremembersthatthrow'></a>
```cs
[Fact]
public Task CustomExceptionProp()
{
    var target = new WithCustomException();
    var settings = new VerifySettings();
    settings.IgnoreMembersThatThrow<CustomException>();
    return Verify(target, settings);
}

[Fact]
public Task CustomExceptionPropFluent()
{
    var target = new WithCustomException();
    return Verify(target)
        .IgnoreMembersThatThrow<CustomException>();
}
```
<sup><a href='/src/Verify.Tests/Serialization/SerializationTests.cs#L2255-L2274' title='Snippet source file'>snippet source</a> | <a href='#snippet-ignoremembersthatthrow' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->

Or globally:

<!-- snippet: IgnoreMembersThatThrowGlobal -->
<a id='snippet-ignoremembersthatthrowglobal'></a>
```cs
VerifierSettings.IgnoreMembersThatThrow<CustomException>();
```
<sup><a href='/src/Verify.Tests/Serialization/SerializationTests.cs#L2248-L2252' title='Snippet source file'>snippet source</a> | <a href='#snippet-ignoremembersthatthrowglobal' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->

Result:

<!-- snippet: SerializationTests.CustomExceptionProp.verified.txt -->
<a id='snippet-SerializationTests.CustomExceptionProp.verified.txt'></a>
```txt
{}
```
<sup><a href='/src/Verify.Tests/Serialization/SerializationTests.CustomExceptionProp.verified.txt#L1-L1' title='Snippet source file'>snippet source</a> | <a href='#snippet-SerializationTests.CustomExceptionProp.verified.txt' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->

Ignore by exception type and expression:

<!-- snippet: IgnoreMembersThatThrowExpression -->
<a id='snippet-ignoremembersthatthrowexpression'></a>
```cs
[Fact]
public Task ExceptionMessageProp()
{
    var target = new WithExceptionIgnoreMessage();

    var settings = new VerifySettings();
    settings.IgnoreMembersThatThrow<Exception>(_ => _.Message == "Ignore");
    return Verify(target, settings);
}

[Fact]
public Task ExceptionMessagePropFluent()
{
    var target = new WithExceptionIgnoreMessage();

    return Verify(target)
        .IgnoreMembersThatThrow<Exception>(_ => _.Message == "Ignore");
}
```
<sup><a href='/src/Verify.Tests/Serialization/SerializationTests.cs#L1426-L1447' title='Snippet source file'>snippet source</a> | <a href='#snippet-ignoremembersthatthrowexpression' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->

Or globally:

<!-- snippet: IgnoreMembersThatThrowExpressionGlobal -->
<a id='snippet-ignoremembersthatthrowexpressionglobal'></a>
```cs
VerifierSettings.IgnoreMembersThatThrow<Exception>(_ => _.Message == "Ignore");
```
<sup><a href='/src/Verify.Tests/Serialization/SerializationTests.cs#L1419-L1423' title='Snippet source file'>snippet source</a> | <a href='#snippet-ignoremembersthatthrowexpressionglobal' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->

Result:

<!-- snippet: SerializationTests.ExceptionMessageProp.verified.txt -->
<a id='snippet-SerializationTests.ExceptionMessageProp.verified.txt'></a>
```txt
{}
```
<sup><a href='/src/Verify.Tests/Serialization/SerializationTests.ExceptionMessageProp.verified.txt#L1-L1' title='Snippet source file'>snippet source</a> | <a href='#snippet-SerializationTests.ExceptionMessageProp.verified.txt' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->


## TreatAsString

Certain types, when passed directly in to Verify, are written directly without going through json serialization.

The default mapping is:

<!-- snippet: typeToStringMapping -->
<a id='snippet-typetostringmapping'></a>
```cs
{typeof(ParameterInfo), (target, _) => ((ParameterInfo) target).SimpleName()},
{typeof(ConstructorInfo), (target, _) => ((ConstructorInfo) target).SimpleName()},
{typeof(MethodInfo), (target, _) => ((MethodInfo) target).SimpleName()},
{typeof(PropertyInfo), (target, _) => ((PropertyInfo) target).SimpleName()},
{typeof(FieldInfo), (target, _) => ((FieldInfo) target).SimpleName()},
{typeof(Type), (target, _) => ((Type) target).SimpleName()},
{typeof(string), (target, _) => (string) target},
{typeof(StringBuilder), (target, _) => ((StringBuilder) target).ToString()},
{typeof(StringWriter), (target, _) => ((StringWriter) target).ToString()},
{typeof(bool), (target, _) => ((bool) target).ToString(CultureInfo.InvariantCulture)},
{typeof(short), (target, _) => ((short) target).ToString(CultureInfo.InvariantCulture)},
{typeof(ushort), (target, _) => ((ushort) target).ToString(CultureInfo.InvariantCulture)},
{typeof(int), (target, _) => ((int) target).ToString(CultureInfo.InvariantCulture)},
{typeof(uint), (target, _) => ((uint) target).ToString(CultureInfo.InvariantCulture)},
{typeof(long), (target, _) => ((long) target).ToString(CultureInfo.InvariantCulture)},
{typeof(ulong), (target, _) => ((ulong) target).ToString(CultureInfo.InvariantCulture)},
{typeof(decimal), (target, _) => ((decimal) target).ToString(CultureInfo.InvariantCulture)},
{typeof(BigInteger), (target, _) => ((BigInteger) target).ToString(CultureInfo.InvariantCulture)},
#if NET5_0_OR_GREATER
{typeof(Half), (target, _) => ((Half) target).ToString(CultureInfo.InvariantCulture)},
#endif
#if NET6_0_OR_GREATER
{
    typeof(DateOnly), (target, _) =>
    {
        var date = (DateOnly) target;
        return date.ToString("yyyy-MM-dd", CultureInfo.InvariantCulture);
    }
},
{
    typeof(TimeOnly), (target, _) =>
    {
        var time = (TimeOnly) target;
        return time.ToString("h:mm tt", CultureInfo.InvariantCulture);
    }
},
#endif
{typeof(float), (target, _) => ((float) target).ToString(CultureInfo.InvariantCulture)},
{typeof(double), (target, _) => ((double) target).ToString(CultureInfo.InvariantCulture)},
{typeof(Guid), (target, _) => ((Guid) target).ToString()},
{
    typeof(DateTime), (target, _) =>
    {
        var dateTime = (DateTime) target;
        return dateTime.ToString("yyyy-MM-ddTHH:mm:ss.FFFFFFFz");
    }
},
{
    typeof(DateTimeOffset), (target, _) =>
    {
        var dateTimeOffset = (DateTimeOffset) target;
        return dateTimeOffset.ToString("yyyy-MM-ddTHH:mm:ss.FFFFFFFz", CultureInfo.InvariantCulture);
    }
},
{
    typeof(XmlNode), (target, _) =>
    {
        var converted = (XmlNode) target;
        var document = XDocument.Parse(converted.OuterXml);
        return new(document.ToString(), "xml");
    }
},
{
    typeof(XDocument), (target, _) =>
    {
        var converted = (XDocument) target;
        return new(converted.ToString(), "xml");
    }
},
{
    typeof(XElement), (target, settings) =>
    {
        var converted = (XElement) target;
        return new(converted.ToString(), "xml");
    }
},
{
    typeof(XmlDocument), (target, _) =>
    {
        var xmlDocument = (XmlDocument) target;
        var stringBuilder = new StringBuilder();
        var writerSettings = new XmlWriterSettings
        {
            Indent = true,
            IndentChars = "  ",
            NewLineChars = "\n",
            NewLineHandling = NewLineHandling.Replace
        };
        using (var writer = XmlWriter.Create(stringBuilder, writerSettings))
        {
            xmlDocument.Save(writer);
        }

        return new(stringBuilder.ToString(), "xml");
    }
}
```
<sup><a href='/src/Verify/Serialization/VerifierSettings.cs#L22-L121' title='Snippet source file'>snippet source</a> | <a href='#snippet-typetostringmapping' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->

This bypasses the Guid and DateTime scrubbing mentioned above.

Extra types can be added to this mapping:

<!-- snippet: TreatAsString -->
<a id='snippet-treatasstring'></a>
```cs
VerifierSettings.TreatAsString<ClassWithToString>(
    (target, settings) => target.Property);
```
<sup><a href='/src/Verify.Tests/Snippets/Snippets.cs#L48-L53' title='Snippet source file'>snippet source</a> | <a href='#snippet-treatasstring' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->


## Converting a member

The value of a member can be mutated before serialization:

<!-- snippet: MemberConverter -->
<a id='snippet-memberconverter'></a>
```cs
[Fact]
public Task MemberConverterByExpression()
{
    var input = new MemberTarget
    {
        Field = "FieldValue",
        Property = "PropertyValue"
    };

    // using only the member
    VerifierSettings.MemberConverter<MemberTarget, string>(
        expression: _ => _.Field,
        converter: member => $"{member}_Suffix");

    // using target and member
    VerifierSettings.MemberConverter<MemberTarget, string>(
        expression: _ => _.Property,
        converter: (target, member) => $"{target}_{member}_Suffix");

    return Verify(input);
}
```
<sup><a href='/src/Verify.Tests/Serialization/SerializationTests.cs#L1999-L2023' title='Snippet source file'>snippet source</a> | <a href='#snippet-memberconverter' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->


## SortPropertiesAlphabetically

Serialized properties can optionally be sorted alphabetically, ie ignoring the order they are defined when using reflection.

<!-- snippet: SortProperties -->
<a id='snippet-sortproperties'></a>
```cs
static class ModuleInitializer
{
    [ModuleInitializer]
    public static void Init() =>
        VerifierSettings.SortPropertiesAlphabetically();
}
```
<sup><a href='/src/SortedPropertiesTests/SortedPropertiesTests.cs#L3-L12' title='Snippet source file'>snippet source</a> | <a href='#snippet-sortproperties' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->


## JsonAppender

A JsonAppender allows extra content (key value pairs) to be optionally appended to the output being verified. JsonAppenders can use the current context to determine what should be appended or if anything should be appended.

Register a JsonAppender:

<!-- snippet: RegisterJsonAppender -->
<a id='snippet-registerjsonappender'></a>
```cs
VerifierSettings.RegisterJsonAppender(
    context =>
    {
        if (ShouldInclude(context))
        {
            return new ToAppend("theData", "theValue");
        }

        return null;
    });
```
<sup><a href='/src/Verify.Tests/Converters/JsonAppenderTests.cs#L9-L22' title='Snippet source file'>snippet source</a> | <a href='#snippet-registerjsonappender' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->

When when content is verified:

<!-- snippet: JsonAppender -->
<a id='snippet-jsonappender'></a>
```cs
[Fact]
public Task WithJsonAppender() =>
    Verify("TheValue");
```
<sup><a href='/src/Verify.Tests/Converters/JsonAppenderTests.cs#L35-L41' title='Snippet source file'>snippet source</a> | <a href='#snippet-jsonappender' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->

The content from RegisterJsonAppender will be included in the output:

<!-- snippet: JsonAppenderTests.WithJsonAppender.verified.txt -->
<a id='snippet-JsonAppenderTests.WithJsonAppender.verified.txt'></a>
```txt
{
  target: TheValue,
  theData: theValue
}
```
<sup><a href='/src/Verify.Tests/Converters/JsonAppenderTests.WithJsonAppender.verified.txt#L1-L4' title='Snippet source file'>snippet source</a> | <a href='#snippet-JsonAppenderTests.WithJsonAppender.verified.txt' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->

If the target is a stream or binary file:

<!-- snippet: JsonAppenderStream -->
<a id='snippet-jsonappenderstream'></a>
```cs
[Fact]
public Task Stream() =>
    Verify(IoHelpers.OpenRead("sample.txt"));
```
<sup><a href='/src/Verify.Tests/Converters/JsonAppenderTests.cs#L60-L66' title='Snippet source file'>snippet source</a> | <a href='#snippet-jsonappenderstream' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->

Then the appended content will be added to the `*.00.verified.txt` file:

<!-- snippet: JsonAppenderTests.Stream.00.verified.txt -->
<a id='snippet-JsonAppenderTests.Stream.00.verified.txt'></a>
```txt
{
  target: null,
  theData: theValue
}
```
<sup><a href='/src/Verify.Tests/Converters/JsonAppenderTests.Stream.00.verified.txt#L1-L4' title='Snippet source file'>snippet source</a> | <a href='#snippet-JsonAppenderTests.Stream.00.verified.txt' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->

See [Converters](/docs/converter.md) for more information on `*.00.verified.txt` files.

Examples of extensions using JsonAppenders are [Recorders in Verify.SqlServer](https://github.com/VerifyTests/Verify.SqlServer#recording) and  [Recorders in Verify.EntityFramework](https://github.com/VerifyTests/Verify.EntityFramework#recording).
