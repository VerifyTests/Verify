<!--
GENERATED FILE - DO NOT EDIT
This file was generated by [MarkdownSnippets](https://github.com/SimonCropp/MarkdownSnippets).
Source File: /docs/mdsource/serializer-settings.source.md
To change this file edit the source file and then run MarkdownSnippets.
-->

# Serializer settings

Verify uses [Argon](https://github.com/SimonCropp/Argon) for serialization. See [Default Settings](#default-settings) for on how Argon is used and instructions on how to control that usage.

Serialization settings can be customized at three levels:

 * Method: Will run the verification in the current test method.
 * Class: Will run for all verifications in all test methods for a test class.
 * Global: Will run for test methods on all tests.


## Not valid json

Note that the output is technically not valid json.

 * Names and values are not quoted.
 * Newlines are not escaped.

The reason for these is that it makes approval files cleaner and easier to read and visualize/understand differences.


### UseStrictJson

To use strict json call `VerifierSettings.UseStrictJson`:


#### Globally

<!-- snippet: UseStrictJsonGlobal -->
<a id='snippet-UseStrictJsonGlobal'></a>
```cs
[ModuleInitializer]
public static void Init() =>
    VerifierSettings.UseStrictJson();
```
<sup><a href='/src/StrictJsonTests/ModuleInit.cs#L3-L9' title='Snippet source file'>snippet source</a> | <a href='#snippet-UseStrictJsonGlobal' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->


#### Instance

<!-- snippet: UseStrictJson -->
<a id='snippet-UseStrictJson'></a>
```cs
var target = new TheTarget
{
    Value = "Foo"
};
var settings = new VerifySettings();
settings.UseStrictJson();
await Verify(target, settings)
    .UseStrictJson();
```
<sup><a href='/src/Verify.Tests/Serialization/SerializationTests.cs#L618-L629' title='Snippet source file'>snippet source</a> | <a href='#snippet-UseStrictJson' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->


#### Fluent

<!-- snippet: UseStrictJsonFluent -->
<a id='snippet-UseStrictJsonFluent'></a>
```cs
var target = new TheTarget
{
    Value = "Foo"
};
await Verify(target)
    .UseStrictJson();
```
<sup><a href='/src/Verify.Tests/Serialization/SerializationTests.cs#L634-L643' title='Snippet source file'>snippet source</a> | <a href='#snippet-UseStrictJsonFluent' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->


#### Result

Then this result in

 * The default `.received.` and `.verified.` extensions for serialized verification to be `.json`.
 * `JsonTextWriter.QuoteChar` to be `"`.
 * `JsonTextWriter.QuoteName` to be `true`.

Then when an object is verified:

<!-- snippet: UseStrictJsonVerify -->
<a id='snippet-UseStrictJsonVerify'></a>
```cs
var target = new TheTarget
{
    Value = "Foo"
};
await Verify(target);
```
<sup><a href='/src/StrictJsonTests/Tests.cs#L82-L90' title='Snippet source file'>snippet source</a> | <a href='#snippet-UseStrictJsonVerify' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->

The resulting file will be:

<!-- snippet: Tests.Object.verified.json -->
<a id='snippet-Tests.Object.verified.json'></a>
```json
{
  "Value": "Foo"
}
```
<sup><a href='/src/StrictJsonTests/Tests.Object.verified.json#L1-L3' title='Snippet source file'>snippet source</a> | <a href='#snippet-Tests.Object.verified.json' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->


## UseUtf8NoBom

The default encoding for snapshot files uses UTF-8 with byte order marks (BOM) enable. To disable UTF-8 BOMs, call `VerifierSettings.UseUtf8NoBom`.

<!-- snippet: UseUtf8NoBom -->
<a id='snippet-UseUtf8NoBom'></a>
```cs
public static class ModuleInitializer
{
    [ModuleInitializer]
    public static void Init() =>
        VerifierSettings.UseUtf8NoBom();
}
```
<sup><a href='/src/ModuleInitDocs/UseUtf8NoBom.cs#L3-L12' title='Snippet source file'>snippet source</a> | <a href='#snippet-UseUtf8NoBom' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->


## UseEncoding

To override the encoding used for snapshot files, replacing the default UTF-8 encoding, call `VerifierSettings.UseEncoding` providing a `System.Text.Encoding` instance.

<!-- snippet: UseEncoding -->
<a id='snippet-UseEncoding'></a>
```cs
public static class ModuleInitializer
{
    [ModuleInitializer]
    public static void Init()
    {
        var encoding = new UnicodeEncoding(
            bigEndian: false,
            byteOrderMark: true,
            throwOnInvalidBytes: true);
        VerifierSettings.UseEncoding(encoding);
    }
}
```
<sup><a href='/src/ModuleInitDocs/UseEncoding.cs#L3-L18' title='Snippet source file'>snippet source</a> | <a href='#snippet-UseEncoding' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->


## Default settings

Verify uses [Argon](https://github.com/SimonCropp/Argon) for serialization.

> Argon is a JSON framework for .NET. It is a hard fork of Newtonsoft.Json.

See [Argon documentation](https://github.com/SimonCropp/Argon/blob/main/docs/readme.md)

The default `JsonSerializerSettings` are:

<!-- snippet: defaultSerialization -->
<a id='snippet-defaultSerialization'></a>
```cs
var settings = new JsonSerializerSettings
{
    Formatting = Formatting.Indented,
    ReferenceLoopHandling = ReferenceLoopHandling.Ignore,
    DefaultValueHandling = DefaultValueHandling.Ignore
};
```
<sup><a href='/src/Verify/Serialization/SerializationSettings.cs#L82-L91' title='Snippet source file'>snippet source</a> | <a href='#snippet-defaultSerialization' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->


### Modify Defaults


#### Globally

<!-- snippet: AddExtraSettingsGlobal -->
<a id='snippet-AddExtraSettingsGlobal'></a>
```cs
VerifierSettings
    .AddExtraSettings(_ =>
        _.TypeNameHandling = TypeNameHandling.All);
```
<sup><a href='/src/Verify.Tests/Serialization/SerializationTests.cs#L509-L515' title='Snippet source file'>snippet source</a> | <a href='#snippet-AddExtraSettingsGlobal' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->


#### Instance

<!-- snippet: AddExtraSettings -->
<a id='snippet-AddExtraSettings'></a>
```cs
[Fact]
public Task AddExtraSettings()
{
    var settings = new VerifySettings();
    settings
        .AddExtraSettings(
            _ => _.Error = (currentObject, originalObject, location, exception, handled) =>
                Console.WriteLine(location.Member));
    return Verify("Value", settings);
}
```
<sup><a href='/src/Verify.Tests/Serialization/SerializationTests.cs#L479-L492' title='Snippet source file'>snippet source</a> | <a href='#snippet-AddExtraSettings' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->


#### Fluent

<!-- snippet: AddExtraSettingsFluent -->
<a id='snippet-AddExtraSettingsFluent'></a>
```cs
[Fact]
public Task AddExtraSettingsFluent() =>
    Verify("Value")
        .AddExtraSettings(
            _ => _.Error = (currentObject, originalObject, location, exception, handled) =>
                Console.WriteLine(location.Member));
```
<sup><a href='/src/Verify.Tests/Serialization/SerializationTests.cs#L494-L503' title='Snippet source file'>snippet source</a> | <a href='#snippet-AddExtraSettingsFluent' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->


## QuoteName is false

[JsonTextWriter.QuoteName](https://www.newtonsoft.com/json/help/html/P_Newtonsoft_Json_JsonTextWriter_QuoteName.htm) is set to false. The reason for this is that it makes approval files cleaner and easier to read and visualize/understand differences.


## Empty collections are ignored

By default empty collections are ignored during verification.

To disable this behavior globally use:

<!-- snippet: DontIgnoreEmptyCollections -->
<a id='snippet-DontIgnoreEmptyCollections'></a>
```cs
VerifierSettings.DontIgnoreEmptyCollections();
```
<sup><a href='/src/Verify.Tests/Serialization/SerializationTests.cs#L1497-L1501' title='Snippet source file'>snippet source</a> | <a href='#snippet-DontIgnoreEmptyCollections' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->


## Changing Json.NET settings

Extra Json.NET settings can be made:


### Globally

<!-- snippet: ExtraSettingsGlobal -->
<a id='snippet-ExtraSettingsGlobal'></a>
```cs
VerifierSettings.AddExtraSettings(
    _ => _.TypeNameHandling = TypeNameHandling.All);
```
<sup><a href='/src/Verify.Tests/Snippets/Snippets.cs#L127-L132' title='Snippet source file'>snippet source</a> | <a href='#snippet-ExtraSettingsGlobal' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->


### Instance

<!-- snippet: ExtraSettingsInstance -->
<a id='snippet-ExtraSettingsInstance'></a>
```cs
var settings = new VerifySettings();
settings.AddExtraSettings(
    _ => _.TypeNameHandling = TypeNameHandling.All);
```
<sup><a href='/src/Verify.Tests/Snippets/Snippets.cs#L134-L140' title='Snippet source file'>snippet source</a> | <a href='#snippet-ExtraSettingsInstance' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->


### Json.NET Converter

One common use case is to register a custom [JsonConverter](https://www.newtonsoft.com/json/help/html/CustomJsonConverter.htm). As only writing is required, to help with this there is `WriteOnlyJsonConverter`, and `WriteOnlyJsonConverter<T>`.

<!-- snippet: CompanyConverter -->
<a id='snippet-CompanyConverter'></a>
```cs
class CompanyConverter :
    WriteOnlyJsonConverter<Company>
{
    public override void Write(VerifyJsonWriter writer, Company company) =>
        writer.WriteMember(company, company.Name, "Name");
}
```
<sup><a href='/src/Verify.Tests/Snippets/Snippets.cs#L153-L162' title='Snippet source file'>snippet source</a> | <a href='#snippet-CompanyConverter' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->

<!-- snippet: JsonConverter -->
<a id='snippet-JsonConverter'></a>
```cs
VerifierSettings.AddExtraSettings(
    _ => _.Converters.Add(new CompanyConverter()));
```
<sup><a href='/src/Verify.Tests/Snippets/Snippets.cs#L145-L150' title='Snippet source file'>snippet source</a> | <a href='#snippet-JsonConverter' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->


#### VerifyJsonWriter

`VerifyJsonWriter` exposes the following members:

 * `Counter` property that gives programmatic access to the counting behavior used by [Guid](guids.md), [Date](dates.md), and [Id](#numeric-ids-are-scrubbed) scrubbing.
 * `Serializer` property that exposes the current `JsonSerializer`.
 * `Serialize(object value)` is a convenience method that calls `JsonSerializer.Serialize` passing in the writer instance and the `value` parameter.
 * `WriteProperty<T, TMember>(T target, TMember value, string name)` method that writes a property name and value while respecting other custom serialization settings eg [member converters](#converting-a-member), [ignore rules](#ignoring-a-type) etc.


## Scoped settings

<!-- snippet: ScopedSerializer -->
<a id='snippet-ScopedSerializer'></a>
```cs
[Fact]
public Task ScopedSerializer()
{
    var person = new Person
    {
        GivenNames = "John",
        FamilyName = "Smith"
    };
    var settings = new VerifySettings();
    settings.AddExtraSettings(_ => _.TypeNameHandling = TypeNameHandling.All);
    return Verify(person, settings);
}

[Fact]
public Task ScopedSerializerFluent()
{
    var person = new Person
    {
        GivenNames = "John",
        FamilyName = "Smith"
    };
    return Verify(person)
        .AddExtraSettings(_ => _.TypeNameHandling = TypeNameHandling.All);
}
```
<sup><a href='/src/Verify.Tests/Serialization/SerializationTests.cs#L3682-L3709' title='Snippet source file'>snippet source</a> | <a href='#snippet-ScopedSerializer' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->

Result:

<!-- snippet: Verify.Xunit.Tests/VerifyObjectSamples.ScopedSerializer.verified.txt -->
<a id='snippet-Verify.Xunit.Tests/VerifyObjectSamples.ScopedSerializer.verified.txt'></a>
```txt
{
  $type: VerifyObjectSamples.Person,
  GivenNames: John,
  FamilyName: Smith
}
```
<sup><a href='/src/Verify.Xunit.Tests/VerifyObjectSamples.ScopedSerializer.verified.txt#L1-L5' title='Snippet source file'>snippet source</a> | <a href='#snippet-Verify.Xunit.Tests/VerifyObjectSamples.ScopedSerializer.verified.txt' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->


## Ignoring a type

To ignore all members that match a certain type:

<!-- snippet: AddIgnoreType -->
<a id='snippet-AddIgnoreType'></a>
```cs
[Fact]
public Task IgnoreType()
{
    var target = new IgnoreTypeTarget
    {
        ToIgnore = new()
        {
            Property = "Value"
        },
        ToIgnoreNullable = new()
        {
            Property = "Value"
        },
        ToIgnoreByInterface = new()
        {
            Property = "Value"
        },
        ToIgnoreByBase = new()
        {
            Property = "Value"
        },
        ToIgnoreByBaseGeneric = new()
        {
            Property = "Value"
        },
        ToIgnoreByType = new()
        {
            Property = "Value"
        },
        ToInclude = new()
        {
            Property = "Value"
        },
        ToIncludeNullable = new()
        {
            Property = "Value"
        },
        ToIgnoreStruct = new("Value"),
        ToIgnoreStructNullable = new("Value"),
        ToIncludeStruct = new("Value"),
        ToIncludeStructNullable = new("Value")
    };
    var settings = new VerifySettings();
    settings.IgnoreMembersWithType<ToIgnore>();
    settings.IgnoreMembersWithType<ToIgnoreByType>();
    settings.IgnoreMembersWithType<InterfaceToIgnore>();
    settings.IgnoreMembersWithType<BaseToIgnore>();
    settings.IgnoreMembersWithType(typeof(BaseToIgnoreGeneric<>));
    settings.IgnoreMembersWithType<ToIgnoreStruct>();
    return Verify(target, settings);
}

[Fact]
public Task IgnoreTypeFluent()
{
    var target = new IgnoreTypeTarget
    {
        ToIgnore = new()
        {
            Property = "Value"
        },
        ToIgnoreNullable = new()
        {
            Property = "Value"
        },
        ToIgnoreByInterface = new()
        {
            Property = "Value"
        },
        ToIgnoreByBase = new()
        {
            Property = "Value"
        },
        ToIgnoreByBaseGeneric = new()
        {
            Property = "Value"
        },
        ToIgnoreByType = new()
        {
            Property = "Value"
        },
        ToInclude = new()
        {
            Property = "Value"
        },
        ToIncludeNullable = new()
        {
            Property = "Value"
        },
        ToIgnoreStruct = new("Value"),
        ToIgnoreStructNullable = new("Value"),
        ToIncludeStruct = new("Value"),
        ToIncludeStructNullable = new("Value")
    };
    return Verify(target)
        .IgnoreMembersWithType<ToIgnore>()
        .IgnoreMembersWithType<ToIgnoreByType>()
        .IgnoreMembersWithType<InterfaceToIgnore>()
        .IgnoreMembersWithType<BaseToIgnore>()
        .IgnoreMembersWithType(typeof(BaseToIgnoreGeneric<>))
        .IgnoreMembersWithType<ToIgnoreStruct>();
}
```
<sup><a href='/src/Verify.Tests/Serialization/SerializationTests.cs#L2700-L2805' title='Snippet source file'>snippet source</a> | <a href='#snippet-AddIgnoreType' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->

Or globally:

<!-- snippet: AddIgnoreTypeGlobal -->
<a id='snippet-AddIgnoreTypeGlobal'></a>
```cs
VerifierSettings.IgnoreMembersWithType<ToIgnore>();
```
<sup><a href='/src/Verify.Tests/Serialization/SerializationTests.cs#L2687-L2691' title='Snippet source file'>snippet source</a> | <a href='#snippet-AddIgnoreTypeGlobal' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->

Result:

<!-- snippet: SerializationTests.IgnoreType.verified.txt -->
<a id='snippet-SerializationTests.IgnoreType.verified.txt'></a>
```txt
{
  ToInclude: {
    Property: Value
  },
  ToIncludeNullable: {
    Property: Value
  },
  ToIncludeStruct: {
    Property: Value
  },
  ToIncludeStructNullable: {
    Property: Value
  }
}
```
<sup><a href='/src/Verify.Tests/Serialization/SerializationTests.IgnoreType.verified.txt#L1-L14' title='Snippet source file'>snippet source</a> | <a href='#snippet-SerializationTests.IgnoreType.verified.txt' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->


## Scrub a type

To scrub all members that match a certain type:

<!-- snippet: AddScrubType -->
<a id='snippet-AddScrubType'></a>
```cs
[Fact]
public Task ScrubType()
{
    var target = new IgnoreTypeTarget
    {
        ToIgnore = new()
        {
            Property = "Value"
        },
        ToIgnoreNullable = new()
        {
            Property = "Value"
        },
        ToIgnoreByInterface = new()
        {
            Property = "Value"
        },
        ToIgnoreByBase = new()
        {
            Property = "Value"
        },
        ToIgnoreByBaseGeneric = new()
        {
            Property = "Value"
        },
        ToIgnoreByType = new()
        {
            Property = "Value"
        },
        ToInclude = new()
        {
            Property = "Value"
        },
        ToIncludeNullable = new()
        {
            Property = "Value"
        },
        ToIgnoreStruct = new("Value"),
        ToIgnoreStructNullable = new("Value"),
        ToIncludeStruct = new("Value"),
        ToIncludeStructNullable = new("Value")
    };
    var settings = new VerifySettings();
    settings.ScrubMembersWithType<ToIgnore>();
    settings.ScrubMembersWithType<ToIgnoreByType>();
    settings.ScrubMembersWithType<InterfaceToIgnore>();
    settings.ScrubMembersWithType<BaseToIgnore>();
    settings.ScrubMembersWithType(typeof(BaseToIgnoreGeneric<>));
    settings.ScrubMembersWithType<ToIgnoreStruct>();
    return Verify(target, settings);
}

[Fact]
public Task ScrubTypeFluent()
{
    var target = new IgnoreTypeTarget
    {
        ToIgnore = new()
        {
            Property = "Value"
        },
        ToIgnoreNullable = new()
        {
            Property = "Value"
        },
        ToIgnoreByInterface = new()
        {
            Property = "Value"
        },
        ToIgnoreByBase = new()
        {
            Property = "Value"
        },
        ToIgnoreByBaseGeneric = new()
        {
            Property = "Value"
        },
        ToIgnoreByType = new()
        {
            Property = "Value"
        },
        ToInclude = new()
        {
            Property = "Value"
        },
        ToIncludeNullable = new()
        {
            Property = "Value"
        },
        ToIgnoreStruct = new("Value"),
        ToIgnoreStructNullable = new("Value"),
        ToIncludeStruct = new("Value"),
        ToIncludeStructNullable = new("Value")
    };
    return Verify(target)
        .ScrubMembersWithType<ToIgnore>()
        .ScrubMembersWithType<ToIgnoreByType>()
        .ScrubMembersWithType<InterfaceToIgnore>()
        .ScrubMembersWithType<BaseToIgnore>()
        .ScrubMembersWithType(typeof(BaseToIgnoreGeneric<>))
        .ScrubMembersWithType<ToIgnoreStruct>();
}
```
<sup><a href='/src/Verify.Tests/Serialization/SerializationTests.cs#L2808-L2913' title='Snippet source file'>snippet source</a> | <a href='#snippet-AddScrubType' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->

Or globally:

<!-- snippet: AddScrubTypeGlobal -->
<a id='snippet-AddScrubTypeGlobal'></a>
```cs
VerifierSettings.ScrubMembersWithType<ToIgnore>();
```
<sup><a href='/src/Verify.Tests/Serialization/SerializationTests.cs#L2693-L2697' title='Snippet source file'>snippet source</a> | <a href='#snippet-AddScrubTypeGlobal' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->

Result:

<!-- snippet: SerializationTests.ScrubType.verified.txt -->
<a id='snippet-SerializationTests.ScrubType.verified.txt'></a>
```txt
{
  ToIgnore: {Scrubbed},
  ToIgnoreByType: {Scrubbed},
  ToIgnoreByInterface: {Scrubbed},
  ToIgnoreByBase: {Scrubbed},
  ToIgnoreByBaseGeneric: {Scrubbed},
  ToIgnoreNullable: {Scrubbed},
  ToIgnoreStruct: {Scrubbed},
  ToIgnoreStructNullable: {Scrubbed},
  ToInclude: {
    Property: Value
  },
  ToIncludeNullable: {
    Property: Value
  },
  ToIncludeStruct: {
    Property: Value
  },
  ToIncludeStructNullable: {
    Property: Value
  }
}
```
<sup><a href='/src/Verify.Tests/Serialization/SerializationTests.ScrubType.verified.txt#L1-L22' title='Snippet source file'>snippet source</a> | <a href='#snippet-SerializationTests.ScrubType.verified.txt' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->


## Ignoring an instance

To ignore instances of a type based on delegate:

<!-- snippet: AddIgnoreInstance -->
<a id='snippet-AddIgnoreInstance'></a>
```cs
[Fact]
public Task AddIgnoreInstance()
{
    var target = new IgnoreInstanceTarget
    {
        ToIgnore = new()
        {
            Property = "Ignore"
        },
        ToInclude = new()
        {
            Property = "Include"
        }
    };
    var settings = new VerifySettings();
    settings.IgnoreInstance<Instance>(_ => _.Property == "Ignore");
    return Verify(target, settings);
}

[Fact]
public Task AddIgnoreInstanceFluent()
{
    var target = new IgnoreInstanceTarget
    {
        ToIgnore = new()
        {
            Property = "Ignore"
        },
        ToInclude = new()
        {
            Property = "Include"
        }
    };
    return Verify(target)
        .IgnoreInstance<Instance>(_ => _.Property == "Ignore");
}
```
<sup><a href='/src/Verify.Tests/Serialization/SerializationTests.cs#L2573-L2612' title='Snippet source file'>snippet source</a> | <a href='#snippet-AddIgnoreInstance' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->

Or globally:

<!-- snippet: AddIgnoreInstanceGlobal -->
<a id='snippet-AddIgnoreInstanceGlobal'></a>
```cs
VerifierSettings.IgnoreInstance<Instance>(_ => _.Property == "Ignore");
```
<sup><a href='/src/Verify.Tests/Serialization/SerializationTests.cs#L2560-L2564' title='Snippet source file'>snippet source</a> | <a href='#snippet-AddIgnoreInstanceGlobal' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->

Result:

<!-- snippet: SerializationTests.AddIgnoreInstance.verified.txt -->
<a id='snippet-SerializationTests.AddIgnoreInstance.verified.txt'></a>
```txt
{
  ToInclude: {
    Property: Include
  }
}
```
<sup><a href='/src/Verify.Tests/Serialization/SerializationTests.AddIgnoreInstance.verified.txt#L1-L5' title='Snippet source file'>snippet source</a> | <a href='#snippet-SerializationTests.AddIgnoreInstance.verified.txt' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->


## Scrub a instance

To scrub instances of a type based on delegate:

<!-- snippet: AddScrubInstance -->
<a id='snippet-AddScrubInstance'></a>
```cs
[Fact]
public Task AddScrubInstance()
{
    var target = new IgnoreInstanceTarget
    {
        ToIgnore = new()
        {
            Property = "Ignore"
        },
        ToInclude = new()
        {
            Property = "Include"
        }
    };
    var settings = new VerifySettings();
    settings.ScrubInstance<Instance>(_ => _.Property == "Ignore");
    return Verify(target, settings);
}

[Fact]
public Task AddScrubInstanceFluent()
{
    var target = new IgnoreInstanceTarget
    {
        ToIgnore = new()
        {
            Property = "Ignore"
        },
        ToInclude = new()
        {
            Property = "Include"
        }
    };
    return Verify(target)
        .ScrubInstance<Instance>(_ => _.Property == "Ignore");
}
```
<sup><a href='/src/Verify.Tests/Serialization/SerializationTests.cs#L2614-L2653' title='Snippet source file'>snippet source</a> | <a href='#snippet-AddScrubInstance' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->

Or globally:

<!-- snippet: AddScrubInstanceGlobal -->
<a id='snippet-AddScrubInstanceGlobal'></a>
```cs
VerifierSettings.ScrubInstance<Instance>(_ => _.Property == "Ignore");
```
<sup><a href='/src/Verify.Tests/Serialization/SerializationTests.cs#L2566-L2570' title='Snippet source file'>snippet source</a> | <a href='#snippet-AddScrubInstanceGlobal' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->

Result:

<!-- snippet: SerializationTests.AddScrubInstance.verified.txt -->
<a id='snippet-SerializationTests.AddScrubInstance.verified.txt'></a>
```txt
{
  ToIgnore: {Scrubbed},
  ToInclude: {
    Property: Include
  }
}
```
<sup><a href='/src/Verify.Tests/Serialization/SerializationTests.AddScrubInstance.verified.txt#L1-L6' title='Snippet source file'>snippet source</a> | <a href='#snippet-SerializationTests.AddScrubInstance.verified.txt' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->


## Obsolete members ignored

Members with an [ObsoleteAttribute](https://docs.microsoft.com/en-us/dotnet/api/system.obsoleteattribute) are ignored:

<!-- snippet: WithObsoleteProp -->
<a id='snippet-WithObsoleteProp'></a>
```cs
class WithObsolete
{
    [Obsolete]
    public string ObsoleteProperty { get; set; }

    public string OtherProperty { get; set; }
}

[Fact]
public Task WithObsoleteProp()
{
    var target = new WithObsolete
    {
        ObsoleteProperty = "value1",
        OtherProperty = "value2"
    };
    return Verify(target);
}
```
<sup><a href='/src/Verify.Tests/Serialization/SerializationTests.cs#L3647-L3668' title='Snippet source file'>snippet source</a> | <a href='#snippet-WithObsoleteProp' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->

Result:

<!-- snippet: SerializationTests.WithObsoleteProp.verified.txt -->
<a id='snippet-SerializationTests.WithObsoleteProp.verified.txt'></a>
```txt
{
  OtherProperty: value2
}
```
<sup><a href='/src/Verify.Tests/Serialization/SerializationTests.WithObsoleteProp.verified.txt#L1-L3' title='Snippet source file'>snippet source</a> | <a href='#snippet-SerializationTests.WithObsoleteProp.verified.txt' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->


### Including Obsolete members

Obsolete members can be included using `IncludeObsoletes`:

<!-- snippet: WithObsoletePropIncluded -->
<a id='snippet-WithObsoletePropIncluded'></a>
```cs
[Fact]
public Task WithObsoletePropIncluded()
{
    var target = new WithObsolete
    {
        ObsoleteProperty = "value1",
        OtherProperty = "value2"
    };
    var settings = new VerifySettings();
    settings.IncludeObsoletes();
    return Verify(target, settings);
}

[Fact]
public Task WithObsoletePropIncludedFluent()
{
    var target = new WithObsolete
    {
        ObsoleteProperty = "value1",
        OtherProperty = "value2"
    };
    return Verify(target)
        .IncludeObsoletes();
}
```
<sup><a href='/src/Verify.Tests/Serialization/SerializationTests.cs#L3618-L3645' title='Snippet source file'>snippet source</a> | <a href='#snippet-WithObsoletePropIncluded' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->

Or globally:

<!-- snippet: WithObsoletePropIncludedGlobally -->
<a id='snippet-WithObsoletePropIncludedGlobally'></a>
```cs
VerifierSettings.IncludeObsoletes();
```
<sup><a href='/src/Verify.Tests/Serialization/SerializationTests.cs#L3611-L3615' title='Snippet source file'>snippet source</a> | <a href='#snippet-WithObsoletePropIncludedGlobally' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->

Result:

<!-- snippet: SerializationTests.WithObsoletePropIncluded.verified.txt -->
<a id='snippet-SerializationTests.WithObsoletePropIncluded.verified.txt'></a>
```txt
{
  ObsoleteProperty: value1,
  OtherProperty: value2
}
```
<sup><a href='/src/Verify.Tests/Serialization/SerializationTests.WithObsoletePropIncluded.verified.txt#L1-L4' title='Snippet source file'>snippet source</a> | <a href='#snippet-SerializationTests.WithObsoletePropIncluded.verified.txt' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->


## Ignore member by expressions

To ignore members of a certain type using an expression:

<!-- snippet: IgnoreMemberByExpression -->
<a id='snippet-IgnoreMemberByExpression'></a>
```cs
[Fact]
public Task IgnoreMemberByExpression()
{
    var target = new IgnoreExplicitTarget
    {
        Include = "Value",
        Field = "Value",
        Property = "Value",
        PropertyWithPropertyName = "Value"
    };
    var settings = new VerifySettings();
    settings.IgnoreMembers<IgnoreExplicitTarget>(
        _ => _.Property,
        _ => _.PropertyWithPropertyName,
        _ => _.Field,
        _ => _.GetOnlyProperty,
        _ => _.PropertyThatThrows);
    return Verify(target, settings);
}

[Fact]
public Task IgnoreMemberByExpressionFluent()
{
    var target = new IgnoreExplicitTarget
    {
        Include = "Value",
        Field = "Value",
        Property = "Value"
    };
    return Verify(target)
        .IgnoreMembers<IgnoreExplicitTarget>(
            _ => _.Property,
            _ => _.Field,
            _ => _.GetOnlyProperty,
            _ => _.PropertyThatThrows);
}
```
<sup><a href='/src/Verify.Tests/Serialization/SerializationTests.cs#L3129-L3168' title='Snippet source file'>snippet source</a> | <a href='#snippet-IgnoreMemberByExpression' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->

Or globally

<!-- snippet: IgnoreMemberByExpressionGlobal -->
<a id='snippet-IgnoreMemberByExpressionGlobal'></a>
```cs
VerifierSettings.IgnoreMembers<IgnoreExplicitTarget>(
    _ => _.Property,
    _ => _.PropertyWithPropertyName,
    _ => _.Field,
    _ => _.GetOnlyProperty,
    _ => _.PropertyThatThrows);
```
<sup><a href='/src/Verify.Tests/Serialization/SerializationTests.cs#L3106-L3115' title='Snippet source file'>snippet source</a> | <a href='#snippet-IgnoreMemberByExpressionGlobal' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->

Result:

<!-- snippet: SerializationTests.IgnoreMemberByExpression.verified.txt -->
<a id='snippet-SerializationTests.IgnoreMemberByExpression.verified.txt'></a>
```txt
{
  Include: Value
}
```
<sup><a href='/src/Verify.Tests/Serialization/SerializationTests.IgnoreMemberByExpression.verified.txt#L1-L3' title='Snippet source file'>snippet source</a> | <a href='#snippet-SerializationTests.IgnoreMemberByExpression.verified.txt' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->


## Scrub member by expressions

To scrub members of a certain type using an expression:

<!-- snippet: ScrubMemberByExpression -->
<a id='snippet-ScrubMemberByExpression'></a>
```cs
[Fact]
public Task ScrubMemberByExpression()
{
    var target = new IgnoreExplicitTarget
    {
        Include = "Value",
        Field = "Value",
        Property = "Value",
        PropertyWithPropertyName = "Value"
    };
    var settings = new VerifySettings();
    settings.ScrubMembers<IgnoreExplicitTarget>(
        _ => _.Property,
        _ => _.PropertyWithPropertyName,
        _ => _.Field,
        _ => _.GetOnlyProperty,
        _ => _.PropertyThatThrows);
    return Verify(target, settings);
}

[Fact]
public Task ScrubMemberByExpressionFluent()
{
    var target = new IgnoreExplicitTarget
    {
        Include = "Value",
        Field = "Value",
        Property = "Value"
    };
    return Verify(target)
        .ScrubMembers<IgnoreExplicitTarget>(
            _ => _.Property,
            _ => _.Field,
            _ => _.GetOnlyProperty,
            _ => _.PropertyThatThrows);
}
```
<sup><a href='/src/Verify.Tests/Serialization/SerializationTests.cs#L3170-L3209' title='Snippet source file'>snippet source</a> | <a href='#snippet-ScrubMemberByExpression' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->

Or globally

<!-- snippet: ScrubMemberByExpressionGlobal -->
<a id='snippet-ScrubMemberByExpressionGlobal'></a>
```cs
VerifierSettings.ScrubMembers<IgnoreExplicitTarget>(
    _ => _.Property,
    _ => _.PropertyWithPropertyName,
    _ => _.Field,
    _ => _.GetOnlyProperty,
    _ => _.PropertyThatThrows);
```
<sup><a href='/src/Verify.Tests/Serialization/SerializationTests.cs#L3117-L3126' title='Snippet source file'>snippet source</a> | <a href='#snippet-ScrubMemberByExpressionGlobal' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->

Result:

<!-- snippet: SerializationTests.ScrubMemberByExpression.verified.txt -->
<a id='snippet-SerializationTests.ScrubMemberByExpression.verified.txt'></a>
```txt
{
  Include: Value,
  Field: {Scrubbed},
  Property: {Scrubbed},
  _Custom: {Scrubbed},
  GetOnlyProperty: {Scrubbed},
  PropertyThatThrows: {Scrubbed}
}
```
<sup><a href='/src/Verify.Tests/Serialization/SerializationTests.ScrubMemberByExpression.verified.txt#L1-L8' title='Snippet source file'>snippet source</a> | <a href='#snippet-SerializationTests.ScrubMemberByExpression.verified.txt' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->


## Ignore member by name

To ignore members of a certain type using type and name:

<!-- snippet: IgnoreMemberByName -->
<a id='snippet-IgnoreMemberByName'></a>
```cs
[Fact]
public Task IgnoreMemberByName()
{
    var target = new IgnoreExplicitTarget
    {
        Include = "Value",
        Field = "Value",
        Property = "Value",
        PropertyByName = "Value"
    };
    var settings = new VerifySettings();

    // For all types
    settings.IgnoreMember("PropertyByName");

    // For a specific type
    settings.IgnoreMember(typeof(IgnoreExplicitTarget), "Property");

    // For a specific type generic
    settings.IgnoreMember<IgnoreExplicitTarget>("Field");

    // For a specific type with expression
    settings.IgnoreMember<IgnoreExplicitTarget>(_ => _.PropertyThatThrows);

    return Verify(target, settings);
}

[Fact]
public Task IgnoreMemberByNameFluent()
{
    var target = new IgnoreExplicitTarget
    {
        Include = "Value",
        Field = "Value",
        Property = "Value",
        PropertyByName = "Value"
    };
    return Verify(target)
        // For all types
        .IgnoreMember("PropertyByName")

        // For a specific type
        .IgnoreMember(typeof(IgnoreExplicitTarget), "Property")

        // For a specific type generic
        .IgnoreMember<IgnoreExplicitTarget>("Field")

        // For a specific type with expression
        .IgnoreMember<IgnoreExplicitTarget>(_ => _.PropertyThatThrows);
}
```
<sup><a href='/src/Verify.Tests/Serialization/SerializationTests.cs#L3283-L3336' title='Snippet source file'>snippet source</a> | <a href='#snippet-IgnoreMemberByName' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->

Or globally:

<!-- snippet: IgnoreMemberByNameGlobal -->
<a id='snippet-IgnoreMemberByNameGlobal'></a>
```cs
// For all types
VerifierSettings.IgnoreMember("PropertyByName");

// For a specific type
VerifierSettings.IgnoreMember(typeof(IgnoreExplicitTarget), "Property");

// For a specific type generic
VerifierSettings.IgnoreMember<IgnoreExplicitTarget>("Field");

// For a specific type with expression
VerifierSettings.IgnoreMember<IgnoreExplicitTarget>(_ => _.PropertyThatThrows);
```
<sup><a href='/src/Verify.Tests/Serialization/SerializationTests.cs#L3250-L3264' title='Snippet source file'>snippet source</a> | <a href='#snippet-IgnoreMemberByNameGlobal' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->

Result:

<!-- snippet: SerializationTests.IgnoreMemberByName.verified.txt -->
<a id='snippet-SerializationTests.IgnoreMemberByName.verified.txt'></a>
```txt
{
  Include: Value,
  GetOnlyProperty: asd
}
```
<sup><a href='/src/Verify.Tests/Serialization/SerializationTests.IgnoreMemberByName.verified.txt#L1-L4' title='Snippet source file'>snippet source</a> | <a href='#snippet-SerializationTests.IgnoreMemberByName.verified.txt' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->


## Scrub member by name

To scrub members of a certain type using type and name:

<!-- snippet: ScrubMemberByName -->
<a id='snippet-ScrubMemberByName'></a>
```cs
[Fact]
public Task ScrubMemberByName()
{
    var target = new IgnoreExplicitTarget
    {
        Include = "Value",
        Field = "Value",
        Property = "Value",
        PropertyByName = "Value"
    };
    var settings = new VerifySettings();

    // For all types
    settings.ScrubMember("PropertyByName");

    // For a specific type
    settings.ScrubMember(typeof(IgnoreExplicitTarget), "Property");

    // For a specific type generic
    settings.ScrubMember<IgnoreExplicitTarget>("Field");

    // For a specific type with expression
    settings.ScrubMember<IgnoreExplicitTarget>(_ => _.PropertyThatThrows);

    return Verify(target, settings);
}

[Fact]
public Task ScrubMemberByNameFluent()
{
    var target = new IgnoreExplicitTarget
    {
        Include = "Value",
        Field = "Value",
        Property = "Value",
        PropertyByName = "Value"
    };
    return Verify(target)
        // For all types
        .ScrubMember("PropertyByName")

        // For a specific type
        .ScrubMember(typeof(IgnoreExplicitTarget), "Property")

        // For a specific type generic
        .ScrubMember<IgnoreExplicitTarget>("Field")

        // For a specific type with expression
        .ScrubMember<IgnoreExplicitTarget>(_ => _.PropertyThatThrows);
}
```
<sup><a href='/src/Verify.Tests/Serialization/SerializationTests.cs#L3338-L3391' title='Snippet source file'>snippet source</a> | <a href='#snippet-ScrubMemberByName' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->

Or globally:

<!-- snippet: ScrubMemberByNameGlobal -->
<a id='snippet-ScrubMemberByNameGlobal'></a>
```cs
// For all types
VerifierSettings.ScrubMember("PropertyByName");

// For a specific type
VerifierSettings.ScrubMember(typeof(IgnoreExplicitTarget), "Property");

// For a specific type generic
VerifierSettings.ScrubMember<IgnoreExplicitTarget>("Field");

// For a specific type with expression
VerifierSettings.ScrubMember<IgnoreExplicitTarget>(_ => _.PropertyThatThrows);
```
<sup><a href='/src/Verify.Tests/Serialization/SerializationTests.cs#L3266-L3280' title='Snippet source file'>snippet source</a> | <a href='#snippet-ScrubMemberByNameGlobal' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->

Result:

<!-- snippet: SerializationTests.ScrubMemberByName.verified.txt -->
<a id='snippet-SerializationTests.ScrubMemberByName.verified.txt'></a>
```txt
{
  Include: Value,
  Field: {Scrubbed},
  Property: {Scrubbed},
  PropertyByName: {Scrubbed},
  GetOnlyProperty: asd,
  PropertyThatThrows: {Scrubbed}
}
```
<sup><a href='/src/Verify.Tests/Serialization/SerializationTests.ScrubMemberByName.verified.txt#L1-L8' title='Snippet source file'>snippet source</a> | <a href='#snippet-SerializationTests.ScrubMemberByName.verified.txt' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->


## Members that throw

Members that throw exceptions can be excluded from serialization based on the exception type or properties.

By default members that throw `NotImplementedException` or `NotSupportedException` are ignored.

Note that this is global for all members on all types.

Ignore by exception type:

<!-- snippet: IgnoreMembersThatThrow -->
<a id='snippet-IgnoreMembersThatThrow'></a>
```cs
[Fact]
public Task CustomExceptionProp()
{
    var target = new WithCustomException();
    var settings = new VerifySettings();
    settings.IgnoreMembersThatThrow<CustomException>();
    return Verify(target, settings);
}

[Fact]
public Task CustomExceptionPropFluent()
{
    var target = new WithCustomException();
    return Verify(target)
        .IgnoreMembersThatThrow<CustomException>();
}
```
<sup><a href='/src/Verify.Tests/Serialization/SerializationTests.cs#L3499-L3518' title='Snippet source file'>snippet source</a> | <a href='#snippet-IgnoreMembersThatThrow' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->

Or globally:

<!-- snippet: IgnoreMembersThatThrowGlobal -->
<a id='snippet-IgnoreMembersThatThrowGlobal'></a>
```cs
VerifierSettings.IgnoreMembersThatThrow<CustomException>();
```
<sup><a href='/src/Verify.Tests/Serialization/SerializationTests.cs#L3492-L3496' title='Snippet source file'>snippet source</a> | <a href='#snippet-IgnoreMembersThatThrowGlobal' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->

Result:

<!-- snippet: SerializationTests.CustomExceptionProp.verified.txt -->
<a id='snippet-SerializationTests.CustomExceptionProp.verified.txt'></a>
```txt
{}
```
<sup><a href='/src/Verify.Tests/Serialization/SerializationTests.CustomExceptionProp.verified.txt#L1-L1' title='Snippet source file'>snippet source</a> | <a href='#snippet-SerializationTests.CustomExceptionProp.verified.txt' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->

Ignore by exception type and expression:

<!-- snippet: IgnoreMembersThatThrowExpression -->
<a id='snippet-IgnoreMembersThatThrowExpression'></a>
```cs
[Fact]
public Task ExceptionMessageProp()
{
    var target = new WithExceptionIgnoreMessage();

    var settings = new VerifySettings();
    settings.IgnoreMembersThatThrow<Exception>(_ => _.Message == "Ignore");
    return Verify(target, settings);
}

[Fact]
public Task ExceptionMessagePropFluent()
{
    var target = new WithExceptionIgnoreMessage();

    return Verify(target)
        .IgnoreMembersThatThrow<Exception>(_ => _.Message == "Ignore");
}
```
<sup><a href='/src/Verify.Tests/Serialization/SerializationTests.cs#L2317-L2338' title='Snippet source file'>snippet source</a> | <a href='#snippet-IgnoreMembersThatThrowExpression' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->

Or globally:

<!-- snippet: IgnoreMembersThatThrowExpressionGlobal -->
<a id='snippet-IgnoreMembersThatThrowExpressionGlobal'></a>
```cs
VerifierSettings.IgnoreMembersThatThrow<Exception>(_ => _.Message == "Ignore");
```
<sup><a href='/src/Verify.Tests/Serialization/SerializationTests.cs#L2310-L2314' title='Snippet source file'>snippet source</a> | <a href='#snippet-IgnoreMembersThatThrowExpressionGlobal' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->

Result:

<!-- snippet: SerializationTests.ExceptionMessageProp.verified.txt -->
<a id='snippet-SerializationTests.ExceptionMessageProp.verified.txt'></a>
```txt
{}
```
<sup><a href='/src/Verify.Tests/Serialization/SerializationTests.ExceptionMessageProp.verified.txt#L1-L1' title='Snippet source file'>snippet source</a> | <a href='#snippet-SerializationTests.ExceptionMessageProp.verified.txt' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->


## TreatAsString

Certain types, when passed directly in to Verify, are written directly without going through json serialization.

The default mapping is:

<!-- snippet: typeToStringMapping -->
<a id='snippet-typeToStringMapping'></a>
```cs
{
    typeof(StringBuilder), (target, _) => ((StringBuilder) target).ToString()
},
{
    typeof(StringWriter), (target, _) => ((StringWriter) target).ToString()
},
{
    typeof(bool), (target, _) => ((bool) target).ToString(Culture.InvariantCulture)
},
{
    typeof(short), (target, _) => ((short) target).ToString(Culture.InvariantCulture)
},
{
    typeof(ushort), (target, _) => ((ushort) target).ToString(Culture.InvariantCulture)
},
{
    typeof(int), (target, _) => ((int) target).ToString(Culture.InvariantCulture)
},
{
    typeof(uint), (target, _) => ((uint) target).ToString(Culture.InvariantCulture)
},
{
    typeof(long), (target, _) => ((long) target).ToString(Culture.InvariantCulture)
},
{
    typeof(ulong), (target, _) => ((ulong) target).ToString(Culture.InvariantCulture)
},
{
    typeof(decimal), (target, _) => ((decimal) target).ToString(Culture.InvariantCulture)
},
{
    typeof(BigInteger), (target, _) => ((BigInteger) target).ToString(Culture.InvariantCulture)
},
#if NET5_0_OR_GREATER
{
    typeof(Half), (target, _) => ((Half) target).ToString(Culture.InvariantCulture)
},
#endif
#if NET6_0_OR_GREATER
{
    typeof(Date), (target, _) =>
    {
        var date = (Date) target;
        return date.ToString("yyyy-MM-dd", Culture.InvariantCulture);
    }
},
{
    typeof(Time), (target, _) =>
    {
        var time = (Time) target;
        return time.ToString("h:mm tt", Culture.InvariantCulture);
    }
},
#endif
{
    typeof(float), (target, _) => ((float) target).ToString(Culture.InvariantCulture)
},
{
    typeof(double), (target, _) => ((double) target).ToString(Culture.InvariantCulture)
},
{
    typeof(Guid), (target, _) => ((Guid) target).ToString()
},
{
    typeof(DateTime), (target, _) => DateFormatter.ToJsonString((DateTime) target)
},
{
    typeof(DateTimeOffset), (target, _) => DateFormatter.ToJsonString((DateTimeOffset) target)
},
{
    typeof(XmlNode), (target, _) =>
    {
        var converted = (XmlNode) target;
        var document = XDocument.Parse(converted.OuterXml);
        return new(document.ToString(), "xml");
    }
},
{
    typeof(XElement), (target, settings) =>
    {
        var converted = (XElement) target;
        return new(converted.ToString(), "xml");
    }
},
```
<sup><a href='/src/Verify/Serialization/VerifierSettings.cs#L38-L125' title='Snippet source file'>snippet source</a> | <a href='#snippet-typeToStringMapping' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->

This bypasses the Guid and DateTime scrubbing.

Extra types can be added to this mapping:

<!-- snippet: TreatAsString -->
<a id='snippet-TreatAsString'></a>
```cs
VerifierSettings.TreatAsString<ClassWithToString>(
    (target, settings) => target.Property);
```
<sup><a href='/src/Verify.Tests/Snippets/Snippets.cs#L39-L44' title='Snippet source file'>snippet source</a> | <a href='#snippet-TreatAsString' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->


## Converting a member

The value of a member can be mutated before serialization:

<!-- snippet: MemberConverter -->
<a id='snippet-MemberConverter'></a>
```cs
[ModuleInitializer]
public static void MemberConverterByExpressionInit()
{
    // using only the member
    VerifierSettings.MemberConverter<MemberTarget, string>(
        expression: _ => _.Field,
        converter: member => $"{member}_Suffix");

    // using target and member
    VerifierSettings.MemberConverter<MemberTarget, string>(
        expression: _ => _.Property,
        converter: (target, member) => $"{target}_{member}_Suffix");
}

[Fact]
public Task MemberConverterByExpression()
{
    var input = new MemberTarget
    {
        Field = "FieldValue",
        Property = "PropertyValue"
    };

    return Verify(input);
}
```
<sup><a href='/src/Verify.Tests/Serialization/SerializationTests.cs#L3211-L3239' title='Snippet source file'>snippet source</a> | <a href='#snippet-MemberConverter' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->


## SortPropertiesAlphabetically

Serialized properties can optionally be sorted alphabetically, ie ignoring the order they are defined when using reflection.

<!-- snippet: SortProperties -->
<a id='snippet-SortProperties'></a>
```cs
public static class ModuleInitializer
{
    [ModuleInitializer]
    public static void Init() =>
        VerifierSettings.SortPropertiesAlphabetically();
}
```
<sup><a href='/src/ModuleInitDocs/SortedProperties.cs#L3-L12' title='Snippet source file'>snippet source</a> | <a href='#snippet-SortProperties' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->


## Dictionary sorting

Dictionaries are sorted by key.

To disable use:

<!-- snippet: DontSortDictionaries -->
<a id='snippet-DontSortDictionaries'></a>
```cs
[Fact]
public Task DontSortDictionaries()
{
    var dictionary = new Dictionary<string, string>
    {
        {
            "Entry_1", "1234"
        },
        {
            "Entry_3", "1234"
        },
        {
            "Entry_2", "5678"
        }
    };

    return Verify(dictionary)
        .DontSortDictionaries();
}
```
<sup><a href='/src/Verify.Tests/Serialization/OrderTests.cs#L176-L198' title='Snippet source file'>snippet source</a> | <a href='#snippet-DontSortDictionaries' title='Start of snippet'>anchor</a></sup>
<a id='snippet-DontSortDictionaries-1'></a>
```cs
[Fact]
public Task DontSortDictionaries()
{
    var dictionary = new Dictionary<string, string>
    {
        {
            "Entry_1", "1234"
        },
        {
            "Entry_3", "1234"
        },
        {
            "Entry_2", "5678"
        }
    };

    return Verify(dictionary)
        .DontSortDictionaries();
}
```
<sup><a href='/src/Verify.Tests/Serialization/SerializationTests.cs#L140-L162' title='Snippet source file'>snippet source</a> | <a href='#snippet-DontSortDictionaries-1' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->


## Json/JObject sorting

Json and JObject are not sorted.

To enable sorting use:

<!-- snippet: SortJsonObjects -->
<a id='snippet-SortJsonObjects'></a>
```cs
public static class ModuleInitializer
{
    [ModuleInitializer]
    public static void Init() =>
        VerifierSettings.SortJsonObjects();
}
```
<sup><a href='/src/ModuleInitDocs/SortedJson.cs#L3-L12' title='Snippet source file'>snippet source</a> | <a href='#snippet-SortJsonObjects' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->


## Ordering IEnumerable items

Items in an instance of an IEnumerable can be ordered.

This is helpful when verifying items that can have an inconsistent order, for example reading items from a database.


### OrderEnumerableBy


#### Globally

<!-- snippet: OrderEnumerableByGlobal -->
<a id='snippet-OrderEnumerableByGlobal'></a>
```cs
[ModuleInitializer]
public static void OrderEnumerableByInitializer() =>
    VerifierSettings.OrderEnumerableBy<TargetForGlobalDescending>(_ => _.Value);
```
<sup><a href='/src/Verify.Tests/Serialization/OrderTests.cs#L3-L9' title='Snippet source file'>snippet source</a> | <a href='#snippet-OrderEnumerableByGlobal' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->


#### Instance

<!-- snippet: OrderEnumerableBy -->
<a id='snippet-OrderEnumerableBy'></a>
```cs
[Fact]
public Task EnumerableOrder()
{
    var settings = new VerifySettings();
    settings.OrderEnumerableBy<Target>(_ => _.Value);
    return Verify(
        new List<Target>
        {
            new("a"),
            new("c"),
            new("b")
        },
        settings);
}
```
<sup><a href='/src/Verify.Tests/Serialization/OrderTests.cs#L45-L62' title='Snippet source file'>snippet source</a> | <a href='#snippet-OrderEnumerableBy' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->


#### Fluent

<!-- snippet: OrderEnumerableByFluent -->
<a id='snippet-OrderEnumerableByFluent'></a>
```cs
[Fact]
public Task EnumerableOrderFluent() =>
    Verify(
            new List<Target>
            {
                new("a"),
                new("c"),
                new("b")
            })
        .OrderEnumerableBy<Target>(_ => _.Value);
```
<sup><a href='/src/Verify.Tests/Serialization/OrderTests.cs#L98-L111' title='Snippet source file'>snippet source</a> | <a href='#snippet-OrderEnumerableByFluent' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->


#### Result

Then this result in

<!-- snippet: OrderTests.EnumerableOrder.verified.txt -->
<a id='snippet-OrderTests.EnumerableOrder.verified.txt'></a>
```txt
[
  {
    Value: a
  },
  {
    Value: b
  },
  {
    Value: c
  }
]
```
<sup><a href='/src/Verify.Tests/Serialization/OrderTests.EnumerableOrder.verified.txt#L1-L11' title='Snippet source file'>snippet source</a> | <a href='#snippet-OrderTests.EnumerableOrder.verified.txt' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->


### OrderEnumerableByDescending


#### Globally

<!-- snippet: OrderEnumerableByDescendingGlobal -->
<a id='snippet-OrderEnumerableByDescendingGlobal'></a>
```cs
[ModuleInitializer]
public static void OrderEnumerableByDescendingInitializer() =>
    VerifierSettings.OrderEnumerableByDescending<TargetForGlobalDescending>(_ => _.Value);
```
<sup><a href='/src/Verify.Tests/Serialization/OrderTests.cs#L23-L29' title='Snippet source file'>snippet source</a> | <a href='#snippet-OrderEnumerableByDescendingGlobal' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->


#### Instance

<!-- snippet: OrderEnumerableByDescending -->
<a id='snippet-OrderEnumerableByDescending'></a>
```cs
[Fact]
public Task OrderEnumerableByDescending()
{
    var settings = new VerifySettings();
    settings.OrderEnumerableByDescending<Target>(_ => _.Value);
    return Verify(
        new List<Target>
        {
            new("a"),
            new("c"),
            new("b")
        },
        settings);
}
```
<sup><a href='/src/Verify.Tests/Serialization/OrderTests.cs#L79-L96' title='Snippet source file'>snippet source</a> | <a href='#snippet-OrderEnumerableByDescending' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->


#### Fluent

<!-- snippet: OrderEnumerableByDescendingFluent -->
<a id='snippet-OrderEnumerableByDescendingFluent'></a>
```cs
[Fact]
public Task OrderEnumerableByDescendingFluent() =>
    Verify(
            new List<Target>
            {
                new("a"),
                new("c"),
                new("b")
            })
        .OrderEnumerableByDescending<Target>(_ => _.Value);
```
<sup><a href='/src/Verify.Tests/Serialization/OrderTests.cs#L113-L126' title='Snippet source file'>snippet source</a> | <a href='#snippet-OrderEnumerableByDescendingFluent' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->


#### Result

Then this result in

<!-- snippet: OrderTests.OrderEnumerableByDescending.verified.txt -->
<a id='snippet-OrderTests.OrderEnumerableByDescending.verified.txt'></a>
```txt
[
  {
    Value: c
  },
  {
    Value: b
  },
  {
    Value: a
  }
]
```
<sup><a href='/src/Verify.Tests/Serialization/OrderTests.OrderEnumerableByDescending.verified.txt#L1-L11' title='Snippet source file'>snippet source</a> | <a href='#snippet-OrderTests.OrderEnumerableByDescending.verified.txt' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->



## JsonAppender

A JsonAppender allows extra content (key value pairs) to be optionally appended to the output being verified. JsonAppenders can use the current context to determine what should be appended or if anything should be appended.

Register a JsonAppender:

<!-- snippet: RegisterJsonAppender -->
<a id='snippet-RegisterJsonAppender'></a>
```cs
VerifierSettings.RegisterJsonAppender(
    context =>
    {
        if (ShouldInclude(context))
        {
            return new ToAppend("theData", "theValue");
        }

        return null;
    });
```
<sup><a href='/src/Verify.Tests/Converters/JsonAppenderTests.cs#L8-L21' title='Snippet source file'>snippet source</a> | <a href='#snippet-RegisterJsonAppender' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->

When when content is verified:

<!-- snippet: JsonAppender -->
<a id='snippet-JsonAppender'></a>
```cs
[Fact]
public Task WithJsonAppender() =>
    Verify("TheValue");
```
<sup><a href='/src/Verify.Tests/Converters/JsonAppenderTests.cs#L34-L40' title='Snippet source file'>snippet source</a> | <a href='#snippet-JsonAppender' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->

The content from RegisterJsonAppender will be included in the output:

<!-- snippet: JsonAppenderTests.WithJsonAppender.verified.txt -->
<a id='snippet-JsonAppenderTests.WithJsonAppender.verified.txt'></a>
```txt
{
  target: TheValue,
  theData: theValue
}
```
<sup><a href='/src/Verify.Tests/Converters/JsonAppenderTests.WithJsonAppender.verified.txt#L1-L4' title='Snippet source file'>snippet source</a> | <a href='#snippet-JsonAppenderTests.WithJsonAppender.verified.txt' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->

If the target is a stream or binary file:

<!-- snippet: JsonAppenderStream -->
<a id='snippet-JsonAppenderStream'></a>
```cs
[Fact]
public Task Stream() =>
    Verify(IoHelpers.OpenRead("sample.txt"));
```
<sup><a href='/src/Verify.Tests/Converters/JsonAppenderTests.cs#L68-L74' title='Snippet source file'>snippet source</a> | <a href='#snippet-JsonAppenderStream' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->

Then the appended content will be added to the `.verified.txt` file:

<!-- snippet: JsonAppenderTests.Stream#00.verified.txt -->
<a id='snippet-JsonAppenderTests.Stream#00.verified.txt'></a>
```txt
{
  target: null,
  theData: theValue
}
```
<sup><a href='/src/Verify.Tests/Converters/JsonAppenderTests.Stream#00.verified.txt#L1-L4' title='Snippet source file'>snippet source</a> | <a href='#snippet-JsonAppenderTests.Stream#00.verified.txt' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->

See [Converters](/docs/converter.md) for more information on `*.00.verified.txt` files.

Examples of extensions using JsonAppenders are [Recorders in Verify.SqlServer](https://github.com/VerifyTests/Verify.SqlServer#recording) and  [Recorders in Verify.EntityFramework](https://github.com/VerifyTests/Verify.EntityFramework#recording).


## See also

 * [Guid behavior](guids.md)
 * [Date behavior](dates.md)
