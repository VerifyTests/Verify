#if NET6_0_OR_GREATER

[UsesVerify]
public class DateScrubberTests
{
    #region NamedDate

    [ModuleInitializer]
    public static void Init() =>
        VerifierSettings.AddNamedDate(new(1998, 10, 1), "dateName");

    #endregion

    [Theory]
    [InlineData("aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa", "no match")]
    [InlineData("aaaaaaaaaaaaaaaaaaaaaaaa", "no match short")]
    [InlineData("1995-10-01", "simple")]
    [InlineData("a1995-10-01b", "wrapped")]
    [InlineData("1995-10-01b", "trailing")]
    [InlineData("a1995-10-01", "starting")]
    public async Task Dates(string value, string name)
    {
        var counter = Counter.Start();
        try
        {
            var builder = new StringBuilder(value);
            DateScrubber.ReplaceDates(builder, "yyyy-MM-dd", counter, CultureInfo.InvariantCulture);
            await Verify(builder)
                .UseTextForParameters(name);
        }
        finally
        {
            Counter.Stop();
        }
    }

    [Theory]
    [InlineData("1998-10-01", "named")]
    [InlineData("1935-10-01", "instanceNamed")]
    public Task NamedDates(string value, string name) =>
        Verify(
                new
                {
                    value = Date.Parse(value)
                })
            .AddNamedDate(new(1935, 10, 1), "instanceNamed")
            .UseTextForParameters(name);

    [Fact]
    public Task LongestDayName() =>
        Verify(CultureInfo.InvariantCulture.DateTimeFormat.LongestDayName());

    [Fact]
    public Task LongestMonthName()
    {
        var dateTimeFormat = CultureInfo.InvariantCulture.DateTimeFormat;

        var monthNumber = dateTimeFormat.LongestMonthName();
        var monthName = dateTimeFormat.GetMonthName(monthNumber);
        return Verify(new
        {
            monthNumber,
            monthName
        });
    }

    const string monthDayFormat = "MMMM MMM dddd ddd HH:mm:ss";

    [Fact]
    public Task BuildCultureToDate()
    {
        var cultures = CultureInfo.GetCultures(CultureTypes.AllCultures);
        var builder = new StringBuilder(
            """
            // <auto-generated />
            static partial class DateScrubber
            {
                static Dictionary<string, CultureDate> cultureDates = new()
                {

            """);
        foreach (var culture in cultures)
        {
            var formatInfo = culture.DateTimeFormat;
            var longDate = FindLongDate(formatInfo);
            var shortDate = FindShortDate(formatInfo);
            builder.AppendLine(
                $$"""
                          {
                              "{{culture.Name}}",
                              new(
                                  new(2020, {{longDate.Month}}, {{longDate.Day}}, {{longDate.Hour}}, 0, 0),
                                  new(2020, {{shortDate.Month}}, {{shortDate.Day}}, {{shortDate.Hour}}, 0, 0))
                          },
                  """);
        }

        builder.AppendLine(
            """
                };
            }
            """);
        var file = Path.Combine(AttributeReader.GetSolutionDirectory(), "Verify/Serialization/Scrubbers/DateScrubber_Generated.cs");
        File.Delete(file);
        return File.WriteAllTextAsync(file, builder.ToString());
    }

    static DateTime FindLongDate(DateTimeFormatInfo formatInfo)
    {
        DateTime longDate = default;
        var longFormatted = "";
        var amLength = formatInfo.AMDesignator.Length;
        var pmLength = formatInfo.PMDesignator.Length;
        for (var month = 1; month <= 12; month++)
        {
            for (var day = 20; day <= 27; day++)
            {
                DateTime date;
                if (amLength > pmLength)
                {
                    date = new(2023, month, day, 1, 0, 0, 0);
                }
                else
                {
                    date = new(2023, month, day, 13, 0, 0, 0);
                }

                var formatted = date.ToString(monthDayFormat, formatInfo);
                if (formatted.Length > longFormatted.Length)
                {
                    longFormatted = formatted;
                    longDate = date;
                }
            }
        }

        return longDate;
    }

    static DateTime FindShortDate(DateTimeFormatInfo formatInfo)
    {
        DateTime shortDate = default;
        string? shortFormatted = null;
        var amLength = formatInfo.AMDesignator.Length;
        var pmLength = formatInfo.PMDesignator.Length;
        for (var month = 1; month <= 12; month++)
        {
            for (var day = 1; day <= 7; day++)
            {
                DateTime date;
                if (amLength < pmLength)
                {
                    date = new(2023, month, day, 1, 0, 0, 0);
                }
                else
                {
                    date = new(2023, month, day, 13, 0, 0, 0);
                }

                var formatted = date.ToString(monthDayFormat, formatInfo);
                if (shortFormatted == null ||
                    formatted.Length < shortFormatted.Length)
                {
                    shortFormatted = formatted;
                    shortDate = date;
                }
            }
        }

        return shortDate;
    }

    #region InstanceNamedDate

    [Fact]
    public Task InstanceNamedDate() =>
        Verify(
                new
                {
                    value = new Date(1935, 10, 1)
                })
            .AddNamedDate(new(1935, 10, 1), "instanceNamed");

    #endregion
}
#endif